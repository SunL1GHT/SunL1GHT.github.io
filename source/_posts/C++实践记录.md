---
title: C++实践记录
date: 2021-03-23 19:32:35
tags:
- C++
categories:
- 工作实践
---

> Clion中中文字符乱码问题
> https://blog.csdn.net/Cbk_XLL/article/details/78752534

## 基础入门
**a_hello**：输出字符cout，输入字符cin

**b_zhushi**：注释，单行注释和多行注释

**c_variable**：变量，变量存在的意义是方便我们管理内存空间。

语法：数据类型 变量名=变量初始值;

**d_constant**：常量，记录不可更改的数值；define（一般在文件上方）或const（一般在变量定义前加const）

语法：#define 常量名 常量值

const 数据类型 常量名=常量值

**e_keyword**：关键字，关键字不可以做为变量或者常量的名称。

变量命名规则：(建议：在命名时，最好能够做到见名知意)
- 标识符不能是关键字
- 标识符只能是字母、数字、下划线
- 第一个字母只能是字母或下划线
- 区分大小写

**f_datatype**：数据类型，给变量分配一个合适的内存空间。

sizeof关键字，sizeof(数据类型/变量名)

转义字符，实现特定功能，‘\’+字符，\n换行，\t制表、\\反斜杠

1. 整型（短整型、整型、长整型、长长整型），表示整数

2. 浮点型，表示小数

   * 单精度float，7位有效数字
   
   * 双精度double，15~16位有效数字
   
   科学计数法
   
3. 字符型，字符变量只占用1个字节，将转为ASCII存在内存中

4. 字符串型，

   * C风格字符串：char 变量名[]=‘字符串‘
   
   * C++风格字符串：
   
5. 布尔类型bool：True/False，只占1个字节大小，C++中除了0都为真

**g_operator**：运算符，包括算术运算符、赋值运算符、比较运算符、逻辑运算符等

1. 算术运算符
    * 加+减-乘*除/取余%，取余和除法中除数不能为0
    加加++减减--，前置与后置的区别
    
        * 前置递增，先让变量+1 然后进行表达式运算
    
        * 后置递增，先进行表达式运算，后让变量+1

2. 赋值运算符
    =、+=、-=、*=、/=、%=

3. 比较运算符，用于表达式比较
    ==、!=、<、<=、>、>=

4. 逻辑运算符
    !、&&、||

5. 三目运算符
    表达式1?表达式2:表达式3
    
    解释：

    * 若表达式1为真，则执行表达式2
    * 若表达式1为假，则执行表达式3

程序流程结构：顺序结构、选择结构、循环结构

**h_if**：if选择结构

语法：

1、单行if：if(条件){条件满足执行语句}

2、多行if：if(条件){条件满足执行语句}else{条件不满足执行语句}

3、多条件if：if(条件1){条件满足执行语句1}else if(条件2){条件满足执行语句2}else{条件不满足执行语句}

**i_switch**：多条件控制语句
switch(表达式){case N: 执行语句;break;}

switch与if的区别：
* switch的缺点：判断分支时只能是整型或者字符型，不可以是一个区间；同时switch不写break程序会一直向下执行。
* switch的优点：效率高，执行清晰

**j_while**：
语法：while(循环条件){循环语句}

**k_dowhile**：
语法：do(循环语句)while(循环条件);

区别于while语句：do-while会先执行一遍循环语句，再判断循环条件是否成立。

**l_for**：
语法：for(起始表达式;条件表达式;末尾循环体){循环语句}

嵌套循环：
    循环体中再套一层循环

**m_break**：中止循环

**n_continue**：跳出本次循环，进行下一次循环。

**o_goto**：
    goto FLAG;语句1;语句2;FLAG:语句3;
    //将不会执行语句1、2，直接跳转到语句3执行。
   不推荐使用goto语句，不方便阅读，影响代码的逻辑结构，也很容易造成死循环。

## 基础进阶
**a_array**：数组，就是一个集合，存放了相同类型的数据元素。数组索引是从0开始的。

一维数组的定义：

1. 数据类型 数组名[数组长度];

2. 数据类型 数组名[数组长度]={值1,值2，值3……};

3. 数据类型 数组名[]={值1,值2,值3……};

一维数组的数组名：
1、可以统计整个数组在内存中的长度，sizeof(数组名)
2、可以获取数组在内存中的首地址

注意：数组名是一个常量不能进行赋值操作

**b_paixu**：冒泡排序

**c_2Axisarray**：二维数组，列数不可省

二维数组的定义：

1. 数据类型 数组名[行数] [列数];

2. 数据类型 数组名[行数] [列数]={{1,2},{3,4}};

3. 数据类型 数组名[行数] [列数]={1,2,3,4};

4. 数据类型 数组名[] [列数]={1,2,3,4};

二维数组的数组名：

1. 查看二维数组的所占的内存空间

2. 获取二维数组的首地址

**d_func**：函数，将一段经常使用的代码封装起来，减少重复代码

函数定义：

1. 返回值类型

2. 函数名

3. 函数参数

4. 函数体语句

5. return 表达式

函数调用：

语法：
    函数名(参数)
    
值传递：实参传给形参。
    形参发生改变并不会影响实参
    
函数常见样式：
1. 无参无返
2. 有参无返
3. 无参有返
4. 有参有返

函数声明：
    作用：告诉编译器函数的存在

函数的分文件编写：让代码更加清晰

1. 创建.h头文件

2. 创建.cpp源文件

3. 在头文件中写函数的声明，写在ifndef-endif之间

4. 在源文件中写函数的定义

**e_point**：指针，
    作用：间接访问内存，
    可以通过指针来保存一个地址，指针就是地址

指针定义语法：数据类型 * 指针变量名;

指针前加 * 号，表示解引用，找到指针指向的内存中的数据

指针所占的内存空间：
int *p; //在32位系统中，占用4个字节空间；在64位系统中，占用8个字节空间。

指针不论是什么类型，其所占内存空间都是4(或8)个字节。

空指针：指针变量指向内存中编号为0（NULL）的空间，用于初始化指针变量。

注意：空指针所指向的内存地址是不可以访问的。

野指针：指针指向非法的内存空间

空指针和也指着呢都不是我们申请的空间，因此不要访问。

const修饰指针：

1. const修饰指针：常量指针，const int * p=&a;

特点：指针的指向可以修改，但是指针指向的值不可以改
*p=20;（错，指针指向的值不可以改）
p=&b;（对，指针指向可以改）

2. const修饰常量：指针常量，int * const p=&a;

特点：指针的指向不可修改，但是指针指向的值可以改
*p=20（对，指向的值可以改）
p=&b;（错，指针的指向不可修改）

3. const int * const p=&a;

特点：指针指向和指针指向的值都不可修改
*p=20（错，指向的值不可修改）
p=&b;（错，指针的指向不可修改）

**f_pointarray**：指针与数组

**g_pointfunc**：指针和函数

**h_struct**：结构体，允许用户自定义的数据类型，允许用户存储不同的数据类型。

定义语法：
    struct 结构体名{结构体成员列表};

通过结构体创建变量的方式有三种：

1. struct 结构体名 变量名;

2. struct 结构体名 变量名 = {成员1值，成员2值……};

3. 定义结构体时顺便创建变量

**i_structarray**：结构体数组

定义语法：
    struct 结构体名 数组名[元素个数]={{},{},{},…};
    
**j_structpoint**：结构体指针，通过指针访问结构体中的成员

利用操作符->可以通过结构体指针访问结构体属性

**k_struct_struct**：结构体嵌套结构体

作用：结构体中嵌套另一个结构体

例如，每个老师辅导一个学生，一个老师的结构体中，记录着一个学生的结构体

**l_structfunc**：结构体做函数参数

作用：将结构体作为参数向函数中传递。传递方式有：

1. 值传递

2. 地址传递

**n_structconst**：const使用在结构体中
作用：防止误操作。


## 通讯录管理系统

1. 系统需求

利用c++实现通讯录管理系统

实现功能如下：

* 添加联系人，信息包括（姓名、性别、年龄、联系电话、家庭地址），最多纪录1000人

* 显示联系人

* 删除联系人，按姓名删除指定联系人

* 查找联系人，按姓名查看指定联系人

* 修改联系人，按姓名修改指定联系人

* 清空联系人

* 退出通讯录

---

 ## 核心编程

> 主要针对C++面对对象编程技术作详细讲解

### 1. 内存分区模型

* 代码区，存放二进制代码

* 全局区，存放全局变量、静态变量、常量

* 栈区，编译器自动释放，存放函数的参数值，局部变量值

* 堆区，由程序员分配和释放，若不释放，操作系统将会自动回收

**程序运行前**（编译器编译后生成exe文件，未执行该文件前）：

代码区：
    存放CPU执行的机器指令
    特点：1.共享，频繁使用的代码只需要一份代码；2.只读，防止程序意外地修改了它的指令。

全局区：
    该区域在程序结束后由操作系统释放
    包括：全局变量、静态变量、常量（字符串常量、const修饰的全局变量）

**程序运行后**
栈区：
    存放函数参数和局部变量。

堆区：
    由程序员管理释放，释放关键字为delete
    C++中可使用new开辟内存

new关键字
    语法：new 数据类型;

### 2. 引用

**基本语法**
作用：给变量起别名
语法：数据类型 &别名=原名;
> int &b=a;
> b=20
> cout <<a<<endl;   //输出20

**注意事项**
1. 引用必须要初始化
> int &b;   //不合法
> int &b=a; //合法
2. 引用初始化后就不能更改了
> int &b=a; //合法
> int &b=c; //不合法，不能脚踏两只船


**引用作函数参数**
作用:使用引用来以形参更改实参
优点：简化指针，代替地址传递

**引用作函数的返回值**
如果函数的返回值是引用，这个函数就可以作为左值，相当于一个变量。

**引用的本质**
引用在C++中的内部实现是一个**指针常量**。
引用一旦初始化后就不能做改变。int * const b=&a;

**常量引用**
作用：修饰形参，防止误操作。


### 3. 函数提高

**函数的默认值**
语法：返回值类型 函数名(参数=默认值){}
如果我们自己传入数据，就用自己的数据，如果没有，那么就用默认值

注意事项：
1、如果某个位置已经有了默认参数，那么这个位置之后的，从左往右都必须要有默认值
2、如果函数的声明有了默认参数，那么这个函数的实现就不能有默认参数；声明和实现中的默认参数只能有一个。

**函数占位参数**
C++形参中可以有占位参数（只填数据类型），但是调用函数时必须填补位置值
语法：返回值类型 函数名(数据类型){}

* 目前阶段的占位参数还无法使用，之后会进行介绍。
* 占位参数还可以有默认参数

**函数重载**
相同函数名，根据调用的参数选择合适的函数执行，提高复用性。
函数重载满足条件：
1. 同一作用域下（全局函数/成员函数……）
2. 函数名相同
3. 函数参数 **类型不同/个数不同/顺序不同**

注意事项：
* 函数的返回值不可作为函数重载的条件
* 引用作为重载条件
* 函数重载和函数的默认参数


### 4. 类和对象

C++面向对象三大特性：**封装、继承、多态**

#### 4.1 封装
意义：
* 将属性和行为作为一个整体，表现生活中的事物
* 将属性和行为加以权限控制
    访问权限有三种：
    1. 公共权限  public     成员在类内、外都可以访问
    2. 保护权限  protected  成员在类内可以访问，类外不可以访问 儿子可以访问父亲的保护内容
    3. 私有权限  private    成员在类内可以访问，类外不可以访问 儿子不可以访问父亲的隐私内容
struct 和 class的区别
* struct 默认权限为公有
* class 默认权限为私有

**成员属性私有化**
优点：
1. 将所有成员属性设为私有，可以自己控制读写权限
2. 对于写权限，我们可以检测数据的有效性


#### 4.2 对象的初始化和清理

**构造函数和析构函数**：编译器自动调用（空实现），完成对象的初始化和清理工作。

构造函数语法：类名 (){}
1. 构造函数，没有返回值，也没有void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象是会自动调用构造，无需手动调用，而且只会调用一次。

析构函数语法：~类名 (){}
1. 析构函数，没有返回值，也没有void
2. 函数名称与类名相同，在名称前面加上~号
3. 析构函数没有参数，因此不能发生重载
4. 程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次。

**构造函数的分类以及调用**
两种分类方式：
* 按参数分为：有参构造(Person())和无参构造(Person(int a))
* 按类型分为：普通构造和拷贝构造(Person(const Person &p))

三种调用方式：
* 括号法
* 显示法
* 隐式转换法

> 拷贝构造函数的调用时机
> 1. 使用一个已经创建完毕的对象来初始化一个新对象
> 2. 值传递的方式给函数参数传值
> 3. 以值的方式返回局部对象

构造函数的调用规则
C++默认提供：
1. 默认构造函数（无参，函数体为空，即空实现）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数（对属性进行值拷贝）

调用规则是：
* 如果写了一个有参构造函数，那C++就不会生成吗，默认构造函数，但仍会提供一个拷贝构造函数。
* 如果写了一个拷贝构造函数，那C++不会提供其他默认构造函数

**深拷贝和浅拷贝**
浅拷贝：简单的赋值拷贝操作，编译器默认的m_Height=p.m_Height;
深拷贝：在堆区重新申请空间，进行拷贝操作，手动堆区开辟m_Height = new int(*p.m_Height);

> new开辟的空间在堆上，而一般声明的变量存放在栈上。
>
> new出来的是一段空间的首地址。所以一般需要用指针来存放这段地址。

编译器提供的拷贝构造函数是利用的浅拷贝操作
浅拷贝会带来堆区的内存重复释放（必须要释放），所以需要深拷贝解决

如果属性有在堆区开辟的，一定要提供构造函数，防止浅拷贝的问题

**初始化列表**
初始化属性。
语法：
    构造函数():属性1(值1),属性2(值2)…{}

**类对象作为类成员**
C++中的成员可以是另一个类的对象，称为对象成员
当其他类对象作为本类的成员，构造时先构造类对象，再构造自身；析构时先析构本身，再析构类对象。


**静态成员**
在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：

* 静态static 成员变量
    * 所有对象共享同一份数据
    * 在编译阶段分配内存（全局区）
    * 类内声明，类外初始化

* 静态static 成员函数
    * 所有对象共享一个函数
    * 静态成员函数只能访问静态成员变量
    

**C++对象模型和this指针**

成员变量和成员函数分开存储
只有非静态成员变量才属于类的对象

**this指针**
非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码
this指针指向别调用的成员函数所属的对象

this指针是隐含每一个非静态成员函数内的一种指针
this指针不需要定义，直接使用即可

this指针的用途：
* 当形参和成员变量同名时，可用this指针来区分
* 在类的非静态成员函数中返回对象本身，可使用return *this

**空指针访问成员函数**
C++中空指针调用成员函数的，但是也要注意有没有用到this指针
如果用到this指针，需要加以判断保证代码的健壮性

**const修饰成员函数**

常函数：
* 成员函数后加const 就成为常函数
* 常函数内不可以修改成员属性
* 成员属性声明时加关键字mutable后，在常函数中依然可以修改

常对象：
* 声明对象前加const 就成为常对象
* 常对象只能调用常函数

#### 4.3 友元
声明特殊函数访问私有属性
友元的关键字为friend

**o_friend**
全局函数作友元，全局函数就有可以访问私有元素
类作友元，一个类可以访问另一个类中的私有属性。
成员函数作友元，成员函数就可以访问另一个类的私有属性

#### 4.4 运算符重载
对已有的运算符重新进行定义，赋予另一种功能，以适应不同的数据类型。
总结:
1. 对于内置的数据类型的报答是的运算符是不可以更改的
2. 不要滥用运算符重载

* 加号运算符重载+，定义新的两个运算类型的加法
* 左移运算符重载<<，输出自定义的数据类型
* 递增运算符重载++，
* 赋值运算符重载
* 关系运算符重载
* 函数调用运算符重载

```c++
//成员函数重载+号
Person operator+(Person &p)
{
    Person temp;
    temp.m_A=this->m_A+p.m_A;
    temp.m_B=this->m_B+p.m_B;
    return temp;
}
//全局函数重载+号
Person operator+(Person &p1,Person &p2)
{
    Person temp;
    temp.m_A=p1.m_A + p2.m_A;
    temp.m_B=p1.m_B + p2.m_B;
    return temp;
}

Person p3=p1+p2
```

```c++
//递增运算符重载
int a=10;
cout <<++a<<endl;//11
cout <<a<<endl;//11

int b=10;
cout <<b++<<endl;//10
cout <<b<<endl;//11

class Myinteger
{
public:
    Myinteger()
    {
        m_Myint=0
    }
private:
    m_Myint;
};
//前置递增
Myinteger& operator++()
//后置递增
Myinteger operator++(int)
```

```c++
//赋值运算符重载
Person& operator=(Person &p)
{
    //编译器是提供浅拷贝
    //m_Age=p.m_Age;

    //先判断是否有属性在堆区，如果有先释放，然后再深拷贝
    if(m_Age != NULL)
    {
        delete m_Age;
        m_Age = NULL;
    }
    //深拷贝操作
    m_Age = new int(*p.m_Age);
    //返回自身this
    return *this;
}
```

```c++
//关系运算符重载
//==
    bool operator==(Person &p)
    {
        return (this->m_Name==p.m_Name && this->m_Age==p.m_Age)? true: false;
    }
//!=
    bool operator!=(Person &p)
    {
        return (this->m_Name==p.m_Name && this->m_Age==p.m_Age)? false: true;
    }
```
```c++
//函数调用重载
class MyAdd
{
public:
    int operator()(int num1, int num2)
    {
        return num1+num2;
    }
};
void test()
{
    MyAdd myadd;
    int res = myadd(100,10);
    cout <<"输出1为"<<res << endl;

    //匿名函数对象
    cout << "输出2为"<<MyAdd()(100,20)<< endl;
}
```

#### 4.5 继承
基本语法：```class 子类:继承方式 父类{}```
子类 也称为 派生类
父类 也称为 基类

派生类中的成员，包含两大部分：
一类是从基类继承过来的，一类是自己增加的成员
从基类继承过来的表现其共性，而新增的成员体现了其个性。

继承的好处：减少重复代码

继承方式
1. 公共继承
2. 保护继承
3. 私有继承

![image-20201206153934893](https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20201206153943.png)

对象模型
    父类中所有非静态成员属性都会被子类继承下去
    父类中私有成员属性是被编译器给隐藏了， 因此访问不到，但是确实被继承下去了。

继承中的构造和析构顺序
    子类继承父类后，当创建子类对象，也会调用父类的构造函数。其顺序是父子子父

**继承中同名成员的处理方式**
* 访问子类中的同名成员，直接访问即可，子.成员名
* 访问父类中的同名成员，需要**加作用域**，子.父::成员名
ps:如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有成员函数

**继承同名静态成员处理方式**
继承的静态变量在子类中如何访问呢？
实例化： 类名 对象名;```Son s;``
* 通过对象访问，```s.m_A 或 s.func()``
* 通过类型进行访问，```Son::m_A 或 Son::func()``
如果重名，参考上面，只要加作用域即可

**多继承**
多继承可能会引发父类中有同名成员出现，需要加作用域区分,**C++实际开发中不建议使用多继承。**
语法:```class 子:继承方式 父1, 继承方式 父2``

**菱形继承/钻石继承**
两个派生继承了同一个基类，又有一个类继承了上面的两个派生类

总结：
* 菱形继承带的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
* 利用虚继承可以解决菱形继承的问题

#### 4.6 多态

多态分为两类
静态多态：函数重载和运算符重载属于静态多态，复用函数名
动态多态：派生类和虚函数实现运行时多态

静态多态和动态多态的区别：
* 静态多态的函数地址早绑定 - 编译阶段确定函数地址
* 动态多态的函数地址晚绑定 - 运行阶段确定函数地址

重载，函数名相同，但函数参数不同
重写，函数名相同，形参列表中的所有参数也要相同

多态满足条件：
* 有继承关系
* 子类重写父类中的虚函数

多态的使用条件
* 父类指针引用指向子类对象

纯虚函数
语法：```virtual 返回值类型 函数名 (参数列表)=0;```

当类中有了纯虚函数，这个类也称为抽象类

抽象类特点：
* 无法实例化对象
* 抽象类子类必须重写父类中的纯虚函数，否则也属于抽象类


**虚析构和纯虚析构**

虚析构和纯虚析构的共性：
* 可以解决父类指针释放子类对象
* 都需要有具体的函数实现

虚析构和纯虚析构的异性：
纯虚析构属于抽象类，无法实例化对象。

注意：如果子类中没有堆区数据，可以不写虚析构和纯虚析构

#### 4.7 文件操作

作用：文件可以将数据持久化
需要包含头文件 ``<fstream>``

文件类型
* 文本文件 -  文件以文本的ASCII码形式存储
* 二进制文件 - 文件以文本的二进制形式存储

操作文本的三大类
1. ofstream: 写操作
2. ifstream: 读操作
3. fstream:  读写操作

**写操作**
1. 包含头文件    ```#include <fstream>```
2. 创建流对象    ```ofstream ofs;```
3. 打开文件     ```ofs.open("文件路径",打开方式);```
4. 写数据       ```ofs << "写入的数据"```
5. 关闭文件     ```ofs.close();```

打开方式 | 解释
---|--
ios::in|为读文件而打开文件
ios::out|为写文件而打开文件
ios::ate|初始位置:文件尾
ios::app|追加方式写文件
ios::trunc|如果文件存在先删除，再创建
ios::binary|二进制方式操作文件

注：文件打开方式可以使用多个，需要加 ```|``` 操作符
例如：```ios::binary|ios::out```

**读操作**
1. 包含头文件    ```#include <fstream>```
2. 创建流对象（并判断是否打开成功）    ```ifstream ifs;```
3. 打开文件     ```ifs.open("文件路径",打开方式);```
4. 读数据          四种方式进行读取
5. 关闭文件     ```ifs.close();```

**二进制方式操作文件**

**二进制写**
```ostream &write();```

**二进制读**
```istream &read(char *buffer,int len);```


## 职工管理系统

C++实现一个基于多态的职工管理系统

公司中职工分为：普通员工、经理、老板
显示时，需要包含职工编号、职工姓名、职工岗位以及职责

普通员工职责：完成经理给的任务
经理职责：完成老板给的任务，并下发任务给员工
老板职责：管理公司所有事物

管理系统的功能：
0. 菜单界面
1. 退出管理系统
2. 添加职工信息，不仅可以单独添加，也可以批量添加
    2.1 成员信息打印
```c++
//测试代码
Worker * worker=NULL;
worker =new Employee(1,"张三",1);
worker->ShowInfo();
delete worker;

worker =new Manager(2,"李四",2);
worker->ShowInfo();
delete worker;

worker =new Boss(3,"王五",3);
worker->ShowInfo();
delete worker;
```
   2.2 添加职工信息
   2.3 职工信息保存在文件中
   2.4 读入已有的文件内容
3. 显示职工信息

4. 删除离职职工
    1）判断职工是否存在
    2）判断文件是否存在
    3）输入职工编号
    4）数据前移，最后提示删除成功
5. 修改职工信息，按照编号的方式修改职工个人信息

6. 查找职工信息，按照职工的编号或者姓名查找职工具体信息
    1）按照职工编号查找，添加职工时不允许重复
    2）按照职工姓名

7. 按照编号排序，可以指定排序规则
    1）

8. 清空所有文档，清空前需要再次确认，防止误删

---

## 提高编程
泛型编程和STL技术
### 模板

#### 函数模板
**作用：**建立通用函数，不指定具体返回值和形参类型，都用**虚拟的类型**表示
**语法：**
```c++
template<typename T>
//函数声明或定义
void mySwap(T &a,T &b){/*函数体*/}
//1、自动类型推导
mySwap(a,b);
//2、显式指定类型
mySwap<int>(a,b);
```
> template--生命创建模板
> typename -- 表明后面符号是一个数据类型，可用class替代
> T-- 通用的数据类型，名称可自定义，通常为大写字母（类型参数化）

**注意事项**
* 自动类型推导，必须推导出一致的数据类型T，才可以使用
* 模板必须确定出T的数据类型，才可以使用

**函数模板与一般函数的区别**（主要区别是在会不会发生隐式类型转换，推荐函数模板使用显示指定的方式）
* 普通函数调用时可以发生自动类型转换（隐式类型转换）
* 函数模板调用时，如果是自动类型推导，不会发生隐式类型转换
* 函数模板调用时，如果是显式指定类型，会发生隐式类型转换

**函数模板和一般函数的调用规则**
1. 如果函数模板和一般函数都可以调用，优先调用一般函数
2. 可以通过**空模板参数列表**来强制调用函数模板
3. 函数模板也可以发生重载
4. 如果函数模板可以产生更好的匹配，优先调用函数模板
* 注：既然提供了函数模板就不要再提供重名的普通函数，否则容易出现二义性。

**模板的局限性**
模板的通用性并不是万能的
不能操作数组、自定义的数据类型。
对具体类型使用特定模板
> template <typename T> //一般的函数模板
> template <> bool myCompare(Person &p1, Person &p2)//具体化的函数模板

目的是在STL中能够运用系统提供的模板

#### 类模板
**作用：**与函数模板一样，都是用虚拟类型表示
**语法：**
```c++
template <class T>
//类
template <class nameType, class ageType>
//Perosn类中定义其有参构造：
Person(nameType name, ageType age)
```

**类模板和函数模板的区别**`h_moban_qubiefunc`
1. 类模板没有自动类型推导的方式.--》不能少<>来指定类型
2. 类模板在模板参数列表中可以有默认参数

**类模板中成员函数的创建时机**`i_moban_lei_shiji`
* 普通类中的成员函数一开始就可以创建
* 类模板中的成员函数在调用时才创建

**类模板对象做函数参数**
1. 指定传入类型（最常用）
2. 参数模板化
3. 整个类模板化

**类模板与继承**
* 子类继承的父类是一个类模板时,子类在声明的时候,要制定出父类中的T的类型
* 如果不指定,编译器就无法给子类分配内存
* 如果想灵活指定父类中的T的类型,子类也需要变为类模板

**类模板成员函数的类外实现**
加一个`template <class T1,class T2>`,`Person<T1,T2>::Person(T1 name, T2 age)`

**类模板的分文件编写**
类模板成员函数份文件编写产生的问题以及解决方式
问题：类模板中成员函数创建时机是在调用阶段（一开始不创建），导致分文件编写时链接不到
解决：
* 解决方式1：直接包含.cpp源文件
* 解决方式2：将声明和实现写到同一个文件中，并更改后缀为.hpp，hpp是约定的名称，并不是强制

**类模板和友元**

类模板的类内及类外实现友元
* 全局函数的类内实现 - 直接在类内声明友元（推荐）
* 全局函数的类外实现 - 需要提前让编译器知道全局函数的存在


**类模板的案例**
* 可以对内置数据类型以及自定义数据类型的数据进行存储
* 将数组中的数据存储到堆区
* 构造函数中可以传入数组的容量
* 提供对应的**拷贝构造函数以及operator=，防止浅拷贝问题**
* 提供尾插法和尾删法对数组中的数据进行增加和删除
* 可以通过下标的方式访问数组中的元素
* 可以获取数组中当前元素个数和数组的容量

### STL
目的：代码的的重复利用

STL(standard Template Library,标准模板库)
* 容器(contrainer)
* 算法(algorithm)
* 迭代器(iterator)


STL几乎都采用了函数模板和类模板

**STL的六大组件**
1. 容器：各种数据结构，如vector、array、list、deque、set、map等存放数据
2. 算法：各种常用算法，如sort、find、copy等
3. 迭代器：连接容器和算法
4. 仿函数：类似函数（重载的()），协助算法完成不同的策略
5. 适配器：提供容器、仿函数、迭代器的接口
6. 空间配置器：空间配置与管理

#### 容器
常用的数据结构：数组，链表树，栈队列集合，映射表等

![容器的种类](https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20201219103454.png)

这些容器分为**序列式容器和关联式容器**两种
* 序列式容器：强调值的排序，序列式容器中的每个元素均有固定的位置。
* 关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系。
* 无序容器：位置不重要，重要的是包含在了该集合内。

**vector容器**
容器： `vector`
算法： `for_each`遍历
迭代器：`vector<int>::iterator`

* vector容器存放内置数据类型
* vector容器存放自定义数据类型
* vector容器中嵌套容器

**string容器**
**本质：**是一个类
string和char ***区别**
* char*是一个指针
* string是一个类，类内部封装了char \*，管理这个字符串，是个char \*型的容器。

**特点：**
string类内部封装了很多成员方法
例如：查找find，拷贝copy，删除 delete，替换 replace，插入 insert 
string管理char *所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责

**string构造函数**
构造函数原型：
* `string();`                 创建一个空的字符串例如 string str 
* `string(const char* s);`    使用字符串s初始化
* `string(const string& str);`使用一个string对象初始化另一个string对象
* `string(int n, char c);`    使用n个字符c初始化

**string赋值操作**
赋值的函数原型
* string& operator=(const char *s);     char *类型字符串赋值给当前的字符串
* string& operator=(const string &s);   把字符串s赋给当前的字符串
* string& operator=(char c);            字符赋值给当前的字符串
* string& assign(const char *s);        把字符串s赋给当前的字符串
* string& assign(const char *s, int n); 把字符串s的前n个字符赋给当前的字符串
* string& assign(const string &s);      把字符串s赋给当前字符串
* string& assign(int n, char c);        用n个字符c赋给当前字符串

**string字符串拼接**
字符串末尾追加字符串
重载操作符+=，完全拼接
append，可以指定起始位置和结束位置拼接

* string& operator+=(const char* str);    重载+=操作符
* string& operator+=(const char c);       重载+=操作符
* string& operator+=(const string& str);  重载+=操作符
* string& append(const char *s);          把字符串s连接到当前字符串结尾
* string& append(const char *s, int n);   把字符串s的前n个字符连接到当前字符串结用
* string& append(const string &s);        同Operator+=(const string& str) 
* string& append(const string &s, int pos, int n);字符串s中从pos开始的n个字符连接到字符串结尾

**string字符串查找和替换**
`find`和`rfind`的区别
rfind从右往左查找
 find从左往右查找

replace: 从某处起，n个字符全部替换

**string字符串比较**

compare: 比较两个字符串是否相等

**string字符串存取**
* `char& operator[](int n);`    通过[]方式取字符
* `char& at(int n);`            通过at方法获取字符

**string字符串插入和删除**
string& insert(int pos, const char *s);     插入字符串
string& insert(int pos, const string& str); 插入字符串
string& insert(int pos, int n, char c);     在指定位置插入n个字符c

string& erase(int pos, int n=npos);         除从Pos开始的n个字符

**string子串**
从字符串中获取想要的一部分子串
string substr(int pos=0,int n=npos) const;  返回由pos开始的n个字符组成的字符串

#### 算法
有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法（Algorithms）
算法分为**质变算法和非质变算法**
* 质变算法：是指运算过程中会**更改**区间内的元素的内容。例如拷贝，替换，删除等
* 非质变算法：是指运算过程中**不会更改**区间内的元素内容，例如查找、计数、遍历、寻找极值等

#### 迭代器
提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。
每个容器都有自己专属的迭代器
迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针


种类|功能|支持运算
--|---|--
输入迭代器|对数据的只读访问|只读，支持++，==、!=
输出迭代器|对数据的只写访问|只写，支持++
前向迭代器|读写操作，并能向前推进选代器|读写，支持++、==、!=
**双向选代器**|读写操作，并能向前和向后操作|读写，支持++、--
**随机访问迭代器**|读写操作，可以以跳跃的方式访问任意数据，功能最理的迭代器|读写，支持++、--、[n]、-n、<、>、<=、>=

容器和算法之间通过迭代器进行无缝连接

![迭代器连接容器和算法](https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20201219103000.png)



