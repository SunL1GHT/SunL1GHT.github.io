---
title: C++实践记录
date: 2021-03-23 19:32:35
tags:
- C++
categories:
- 工作实践
---

# 学习记录

C语言和C++有什么区别和联系？
`<>`引用系统头文件
`""`引用用户头文件
多个程序包含同一个头文件，而不用注重引用顺序。
```C++
//防卫式声明
#ifdef __COMPLEX__
#define __COMPLEX__


# endif
```

## 基础入门

## 基础进阶

### 数组

### 函数

### 指针

**指针の作用**：间接访问内存，可以通过指针来保存一个地址，指针就是地址。

**指针の语法**：`数据类型 * 指针变量名;`

指针前加 * 号，表示解引用，找到指针指向的内存中的数据。

指针所占的内存空间：`int *p; //在32位系统中，占用4个字节空间；在64位系统中，占用8个字节空间。`

特别地，指针不论是什么类型，其所占内存空间都是4(或8)个字节。

**空指针**：指针变量指向内存中编号为0（NULL）的空间，用于初始化指针变量。

*注意：空指针所指向的内存地址是不可以访问的。*

**野指针**：指针指向非法的内存空间。

空指针和野指针都不是我们申请的空间，因此不要访问。

**const修饰指针**：

1. const修饰指针：常量指针，`const int * p=&a;`

    特点：指针的指向可以修改，但是指针指向的值不可以改

    * `*p=20;`（错，指针指向的值不可以改）

    * `p=&b;`（对，指针指向可以改）

2. const修饰常量：指针常量，`int * const p=&a;`

    特点：指针的指向不可修改，但是指针指向的值可以改

    * `*p=20;`（对，指向的值可以改）

    * `p=&b;`（错，指针的指向不可修改）

3. `const int * const p=&a;`

    特点：指针指向和指针指向的值都不可修改

    * `*p=20;`（错，指向的值不可修改）

    * `p=&b;`（错，指针的指向不可修改）

### 结构体

## 核心编程

### 内存分区模型

* 代码区，存放二进制代码

* 全局区，存放全局变量、静态变量、常量

* 栈区，编译器自动释放，存放函数的参数值，局部变量值

* 堆区，由程序员分配和释放，若不释放，操作系统将会自动回收

### 引用

**引用の作用**：给变量起别名

**引用の语法**：`数据类型 &别名=原名;`

> **注意事项**
>
> 1. 引用必须要初始化
    > `int &b;`   //不合法`
    > `int &b=a;` //合法
> 
> 2. 引用初始化后就不能更改了
    > `int &b=a;` //合法
    > `int &b=c;` //不合法，不能脚踏两只船

**引用作函数参数**
作用：使用引用来以形参更改实参
优点：简化指针，代替地址传递

**引用作函数的返回值**
如果函数的返回值是引用，这个函数就可以作为左值，相当于一个变量。

**引用的本质**
引用在C++中的内部实现是一个**指针常量**。
引用一旦初始化后就不能做改变。int * const b=&a;

**常量引用**
作用：修饰形参，防止误操作。

### 函数提高（函数重载）

**函数的默认值**
**语法**：`返回值类型 函数名(参数=默认值){}`
如果我们自己传入数据，就用自己的数据，如果没有，那么就用默认值

注意事项：
1、如果某个位置已经有了默认参数，那么这个位置之后的，从左往右都必须要有默认值
2、如果函数的声明有了默认参数，那么这个函数的实现就不能有默认参数；声明和实现中的默认参数只能有一个。

**函数占位参数**
C++形参中可以有占位参数（只填数据类型），但是调用函数时必须填补位置值
语法：`返回值类型 函数名(数据类型){}`

* 目前阶段的占位参数还无法使用，之后会进行介绍。

* 占位参数还可以有默认参数

**函数重载**

**作用**：相同函数名，根据调用的参数选择合适的函数执行，提高复用性。

函数重载满足条件：

1. 同一作用域下（全局函数/成员函数……）
2. 函数名相同
3. 函数参数 **类型不同/个数不同/顺序不同**

注意事项：

* 函数的返回值不可作为函数重载的条件
* 引用作为重载条件
* 函数重载和函数的默认参数

### 类和对象

> C++面向对象三大特性：**封装、继承、多态**

#### 封装

* 将属性和行为作为一个整体，表现生活中的事物

* 将属性和行为加以权限控制，访问权限有三种：
  1. 公共权限  public     成员在类内、外都可以访问
  2. 保护权限  protected  成员在类内可以访问，类外不可以访问 儿子可以访问父亲的保护内容
  3. 私有权限  private    成员在类内可以访问，类外不可以访问 儿子不可以访问父亲的隐私内容

> **成员属性私有化的优点**
> 1. 将所有成员属性设为私有，可以自己控制读写权限
> 2. 对于写权限，我们可以检测数据的有效性

* struct 和 class的区别

    * struct 默认权限为公有

    * class 默认权限为私有

**静态成员**
在成员变量和成员函数前加上关键字`static`，称为静态成员

静态成员分为：

* 静态static 成员变量
    * 所有对象共享同一份数据
    * 在编译阶段分配内存（全局区）
    * 类内声明，类外初始化

* 静态static 成员函数
    * 所有对象共享一个函数
    * 静态成员函数只能访问静态成员变量

**this指针**
非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码
this指针指向别调用的成员函数所属的对象

this指针是隐含每一个非静态成员函数内的一种指针
this指针不需要定义，直接使用即可

this指针的用途：

* 当形参和成员变量同名时，可用this指针来区分
* 在类的非静态成员函数中返回对象本身，可使用return *this

**空指针访问成员函数**
C++中空指针调用成员函数的，但是也要注意有没有用到this指针
如果用到this指针，需要加以判断保证代码的健壮性

**const修饰成员函数**

常函数：

* 成员函数后加const 就成为常函数
* 常函数内不可以修改成员属性
* 成员属性声明时加关键字mutable后，在常函数中依然可以修改

常对象：

* 声明对象前加const 就成为常对象
* 常对象只能调用常函数

<details>
<summary>构造函数与析构函数</summary>

**构造函数和析构函数**：编译器自动调用（空实现），完成**对象的初始化和清理**工作。

构造函数语法：`类名 (){}`
1. 构造函数，没有返回值，也没有void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象是会自动调用构造，无需手动调用，而且只会调用一次。

析构函数语法：`~类名 (){}`

1. 析构函数，没有返回值，也没有void
2. 函数名称与类名相同，在名称前面加上~号
3. 析构函数没有参数，因此不能发生重载
4. 程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次。

**构造函数的分类以及调用**

两种分类方式：

* 按参数分为：有参构造(`Person()`)和无参构造(`Person(int a)`)
* 按类型分为：普通构造和拷贝构造(`Person(const Person &p)`)

三种调用方式：

* 括号法
* 显示法
* 隐式转换法

> 拷贝构造函数的调用时机
>
> 1. 使用一个已经创建完毕的对象来初始化一个新对象
> 2. 值传递的方式给函数参数传值
> 3. 以值的方式返回局部对象

**构造函数的调用规则**
C++默认提供：

1. 默认构造函数（无参，函数体为空，即空实现）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数（对属性进行值拷贝）

调用规则是：

* 如果写了一个有参构造函数，那C++就不会生成吗，默认构造函数，但仍会提供一个拷贝构造函数。
* 如果写了一个拷贝构造函数，那C++不会提供其他默认构造函数

**<center>深拷贝和浅拷贝</center>**
浅拷贝：简单的赋值拷贝操作，编译器默认的m_Height=p.m_Height;
深拷贝：在堆区重新申请空间，进行拷贝操作，手动堆区开辟m_Height = new int(*p.m_Height);

> new开辟的空间在堆上，而一般声明的变量存放在栈上。
>
> new出来的是一段空间的首地址。所以一般需要用指针来存放这段地址。

编译器提供的**拷贝构造函数**是利用的**浅拷贝操作**
浅拷贝会带来堆区的内存重复释放（必须要释放），所以需要深拷贝解决

如果属性有在堆区开辟的，一定要提供构造函数，防止浅拷贝的问题

</details>

<details>
<summary>友元</summary>

**友元の作用**：声明特殊函数访问私有属性
友元的关键字为`friend`

* 全局函数作友元，全局函数就有可以访问私有元素
* 类作友元，一个类可以访问另一个类中的私有属性。
* 成员函数作友元，成员函数就可以访问另一个类的私有属性

</details>

<details>
<summary>运算符重载</summary>

> 对已有的运算符重新进行定义，赋予另一种功能，以适应不同的数据类型。
总结:
1. 对于内置的数据类型的表达式的运算符是不可以更改的
2. 不要滥用运算符重载

* 加号运算符重载+，定义新的两个运算类型的加法
* 左移运算符重载<<，输出自定义的数据类型
* 递增运算符重载++，
* 赋值运算符重载
* 关系运算符重载
* 函数调用运算符重载

</details>

#### 继承

基本语法：`class 子类:继承方式 父类{}`
子类 也称为 派生类
父类 也称为 基类

派生类中的成员，包含两大部分：
一类是从基类继承过来的，一类是自己增加的成员
从基类继承过来的表现其共性，而新增的成员体现了其个性。

继承的好处：减少重复代码

继承方式

1. 公共继承
2. 保护继承
3. 私有继承

![继承方式](https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20201206153943.png)

对象模型
    父类中所有非静态成员属性都会被子类继承下去
    父类中私有成员属性是被编译器给隐藏了， 因此访问不到，但是也确实被继承下去了。

继承中的构造和析构顺序
    子类继承父类后，当创建子类对象，也会调用父类的构造函数。其顺序是**父子子父**

**继承中同名成员的处理方式**

* 访问子类中的同名成员，直接访问即可，`子.成员名`
* 访问父类中的同名成员，需要**加作用域**，`子.父::成员名`
*注意:如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有成员函数*

**继承同名静态成员处理方式**
继承的静态变量在子类中如何访问呢？
实例化： 类名 对象名;`Son s;`

* 通过对象访问，`s.m_A 或 s.func()`
* 通过类型进行访问，`Son::m_A 或 Son::func()`
    如果重名，参考上面，只要**加作用域**即可

**多继承**

多继承可能会引发父类中有同名成员出现，需要加作用域区分,**C++实际开发中不建议使用多继承。**
语法:`class 子:继承方式 父1, 继承方式 父2`

**菱形继承/钻石继承**
两个派生继承了同一个基类，又有一个类继承了上面的两个派生类

总结：
* 菱形继承带的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
* 利用虚继承可以解决菱形继承的问题

**虚继承**



#### 多态

# 实践

socket通信，局域网聊天室，传输Mat图片