---
title: 一次性内窥镜的主机系统设计
date: 2021-03-23 18:56:42
katex: true
tags:
- 图像增强
categories:
- 实验室
---

## 功能需求

1. 白平衡
2. 色彩增强（红色血管、出血点颜色增强）
3. 结构增强（显示细微轮廓）
4. 录像/拍照
5. 菜单：语言、存储格式、患者信息、增强功能设定、日期时间、视频输出格式、U盘格式化
6. 照明亮度调节功能（控制镜头端LED亮度）
7. 上下左右控制

## 内窥镜阶段计划书

### 第一阶段

**<center>图像处理</center>**

- 图像增强：
  - 白平衡，
  - 颜色增强，
  - 结构增强

**<center>界面设计</center>**

- 显示日期时间
- 调用摄像头/读取视频
- 视频输出格式选择
- 图像显示
- 图像增强若干功能按键
- U盘格式化按键
- 界面显示语言切换（中/英）

### 第二阶段

软件

- 引入神经网络中的超分辨率技术，完善结构增强功能

硬件

- 基于树莓派的软件控制，实现独立按钮控制
- 三档控制LED的亮度
- 多端通信及数据传输——显示器（HDMI）、PC端（TCP/IP）

## 实际实现——图像增强

<details>
<summary>图像增强综述</summary>

代码实现：https://www.cnblogs.com/fydeblog/p/10734733.html

- Point Operations
  - Image Negative
  - Contrast Stretching
  - Compression of dynamic range
  - Grey level slicing
  - Image Subtraction
  - Image Averaging
  - Histogram
    - Histogram Equalization
    - adaptive histogram equalization
    - Contrast Limited Adaptive Hitogram Equalization（CLAHE）
- Mask Operations
  - Smoothing operations
  - Median Filtering
  - sharpening operations
  - Derivative operations
- Transform operations
  - Low pass filtering
  - High pass filtering
  - Band pass filtering
  - Homomorphic filtering
- Coloring Operations
  - False coloring
  - Full color processing
- Retinex
  - SSR
  - MSR
  - MSRCR
  - Experiment
- Dark Channel Prior

</details>

## 实际实现——超分辨率

为什么要使用超分辨算法？
通常情况，图像传感器均能获得较好的质量，但在特殊场合，受到诸多因素影响，导致图像质量下降。如图像采集获取过程中：**成像环境、成像距离、传感器形状和大小、光学系统的误差、空气扰动、物体运动、镜头散焦的影响。**

图像数字化处理过程中：成像、转换、编码、压缩、存储都会影响到图像的分辨率。另外**，还有成像噪声、电气噪声、系统噪声的叠加**。所以实际应用中，无法按照理想状况实现，存在的这些因素，必然影响图像的质量，获得较高质量的图像分辨率也是相当困难的。理论上，获得高分辨率只要增加成像系统的个数，最直接的方法是，通过传感器制造技术减小像素尺寸，增加单位面积的成像点阵就可以解决问题。

综上，由于技术水平和经济条件的限制，使得成像传感器和光学器件的性能指标可能无法满足应用的需要，因此，需要采用信号处理方法提高图像分辨率。

**经典的图像插值算法：**

- nearest（邻域像素重复技术）——放大像素大小但不增加细节，会简单地用与其最近邻相同的颜色填充空白像素。它虽然简单而有效，但结果是一个锯齿状、明显像素化的图像。

![nearest原理](https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20210326185216.jpg)

- bilinear（双线性图像插值）——相似三角形原理，均值插值，以周围四个点来得到中间点的值，解决锯齿，但会产生模糊。基于最近的两个像素来分析空白像素，并在它们之间生成一个梯度，这会让图像变得更加清晰。

![bilinear原理](https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20210326185317.jpg)

- bicubic（双三次图像插值），对其16个最近邻像素进行了采样，这样就会让着色变得精确，但仍然存在图像模糊的问题，R. G. Keys, “Cubic convolution interpolation for digital image processing,” IEEE Trans. On Acoustics, Speech, and Signal Processing, ASSP-29(6): 1153-1160, 1981.

![插值算法对比](https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCfK7n1ltJhKRFKFcyL3syI8TmXdMJtATxKiarYmFLVcacDQhb9Aiapumj29TTPBg4W2sicSQDuUEwzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1]

$$ g(x)=\sum\limits_k{c_k \cdot u(\frac {x-x_k}{h})} $$

$$ u(s)=\begin{cases} {A_1}{|s|^3}+{B_1}{|s|^2}+{C_1}{|s|}+{D_1} & 0<|s|<1 \\\\ {A_2}{|s|^3}+{B_2}{|s|^2}+{C_2}{|s|}+{D_2} & 1<|s|<2 \\\\ 0 & 2<{|s|} \end{cases} $$

将u(0)=1,u(1)=0,u(2)=0;s=0,1,2处u'连续A_2=0.5代入上式可得：

$$ u(s)=\begin{cases} \frac {3}{2}{|s|^3}-\frac {5}{2}{|s|^2}+1 & 0<|s|<1 \\\\ -\frac {1}{2}{|s|^3}+\frac {5}{2}{|s|^2}-4{|s|}+2 & 1<|s|<2 \\\\ 0 & 2<{|s|} \end{cases} $$

- 边缘导向差值法——假设自然图像可以用局部的高斯随机过程来描述，基于几何对偶性算出协方差系数使得LR→HR。图片给更光滑，速度快。

$$ \vec{\alpha}=(C^TC)^{-1}\cdot(C^{T}\vec{y}) $$

- in scale BP——单幅图的超分辨率：自相似性（图像内部自相似性以及不同尺寸的自相似性）

  - in-scale：在图像内部搜索相似块，根据相似块计算平均值，放入放大的图像的对应位置
  
  - cross-scale：在不同尺寸（高斯金字塔）图像间搜索相似块，根据相似块计算平均值，放入放大的图像的对应位置

- Superresolution，【ICCV2009】D. Glasner, S. Bagon, and M. Irani, “Super-resolution from a single image,” In Proc. of ICCV, 2009.  

  - back-Projection：缩小高分辨率图像与实际图像之间的误差

![处理流程](https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20210326184457.jpg)

传统的基于插值的算法相比之下，神经网络的优势可以处理更多的信息，超分辨率算法可以分为以下两种：

1. Single Image SR。只参考当前低分辨率图像，不依赖其他相关图像的超分辨率技术，称之为单幅图像的超分辨率（single image super resolution，SISR）。

2. Video SR。参考多幅图像或多个视频帧的超分辨率技术，称之为多帧视频/多图的超分辨率（multi-frame super resolution）。对于Video SR，其核心思想就是用时间带宽换取空间分辨率。简单来讲，就是在无法得到一张超高分辨率的图像时，可以多取相邻几帧，然后将这一系列低分辨率的图像组成一张高分辨的图像。

一般来讲Video SR相比于Image SR具有更多的可参考信息，并具有更好的高分辨率视频图像的重建质量，但是其更高的计算复杂度也限制了其应用。

通常包括两个步骤：首先**图像配准**，即估计低分辨率图像之间亚像素级别的相对位移；其次**图像融合**，将多幅低分辨率图像融合成一幅高分辨率图像。

**分类**

<center>基于重建的方法</center>
通常都是基于多帧图像的，需要结合先验知识。有如下方法：

凸集投影法（POCS)
贝叶斯分析方法
迭代反投影法（IBP）
最大后验概率方法
正规化法
混合方法

<center>基于学习的图像超分辨率</center>
机器学习领域（非深度学习邻域）的图像超分方法如下：

Example-based方法
邻域嵌入方法
支持向量回归方法
虚幻脸
稀疏表示法
<center>基于深度学习的图像超分辨率重建技术</center>
基于深度学习的图像超分辨率重建的研究流程如下：

1，首先找到一组原始图像Image1；
2，然后将这组图片降低分辨率为一组图像Image2；
3，通过各种神经网络结构，将Image2超分辨率重建为Image3（Image3和Image1分辨率一样）
4，通过PSNR等方法比较Image1与Image3，验证超分辨率重建的效果，根据效果调节神经网络中的节点模型和参数
5，反复执行，直到第四步比较的结果满意

**简单试验几个超分辨率的[神经网络模型](https://bbs.cvmart.net/topics/949)：**

<details>
<summary>SRCNN</summary>

![SRCNN](https://bbs.cvmart.net/uploads/images/201909/10/3/ExYpimih7z.png?imageView2/2/w/1240/h/0)

[SRCNN](https://www.bilibili.com/video/BV1pE411H7vd)

</details>

<details>
<summary>DRCN</summary>

提出使用更多的卷积层增加网络感受野（41x41），同时为了避免过多网络参数，该文章提出使用递归神经网络（RNN）。
![DRCN](https://bbs.cvmart.net/uploads/images/201909/10/3/TqII1h1Uyi.png?imageView2/2/w/1240/h/0)

</details>

<details>
<summary>ESPCN</summary>

在SRCNN和DRCN中，低分辨率图像都是先通过上采样插值得到与高分辨率图像同样的大小，再作为网络输入，意味着卷积操作在较高的分辨率上进行，相比于在低分辨率的图像上计算卷积，会降低效率。
![ESPCN](https://bbs.cvmart.net/uploads/images/201909/10/3/e7mc2ZJwJ7.png?imageView2/2/w/1240/h/0)

</details>

<details>
<summary>VESPCN</summary>

在视频图像的SR问题中，相邻几帧具有很强的关联性，上述几种方法都只在单幅图像上进行处理，而VESPCN（ Real-Time Video Super-Resolution with Spatio-Temporal Networks and Motion Compensation, arxiv 2016）提出使用视频中的时间序列图像进行高分辨率重建，并且能达到实时处理的效率要求。
![VESPCN](https://bbs.cvmart.net/uploads/images/201909/10/3/lcTwlTetVQ.png?imageView2/2/w/1240/h/0)

</details>

<details>
<summary>SRGAN</summary>

其出发点是传统的方法一般处理的是较小的放大倍数，当图像的放大倍数在4以上时，很容易使得到的结果显得过于平滑，而缺少一些细节上的真实感。因此SRGAN使用GAN来生成图像中的细节。
![SRGAN](https://bbs.cvmart.net/uploads/images/201909/10/3/L6AKms1aX0.png?imageView2/2/w/1240/h/0)

对抗学习的概念就是引入一个判别器来解决不同数据域之间分布不一致的问题，通过使判别器无法区分两个不同域的数据，间接使它们属于同一个分布，从而作为一个规则化的方法去指导深度学习模型更新参数，达到更好的效果。[参考](https://zhuanlan.zhihu.com/p/25201511)

</details>

<details>
<summary>USRNet</summary>

model-based：将问题公式化，然后通过不断迭代结果，最终得到一个令人较为满意的解

learning-based：深度学习的方法

「单图像超分」《Deep Unfolding Network for Image Super-Resolution》

no-blind已知LR图像，下采样方法，模糊核，噪声的情况下，求对应的HR图像。

</details>


## 实际实现——Qt界面

**调用摄像头**

https://github.com/hjrf/fruit-recognition/blob/master/fruit-identification/%E8%B0%83%E7%94%A8%E7%94%B5%E8%84%91%E6%91%84%E5%83%8F%E5%A4%B4.cpp

**功能按键**

## 实际实现——云服务器进行训练部署

### Docker

Docker 是一个开放源代码软件，是一个开放平台，用于开发应用、交付（shipping）应用、运行应用。 Docker允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。

Docker容器与虚拟机类似，但二者在原理上不同。容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。 容器更多的用于表示 软件的一个标准化单元。由于容器的标准化，因此它可以无视基础设施（Infrastructure）的差异，部署到任何一个地方。另外，Docker也为容器提供更强的业界的隔离兼容。
