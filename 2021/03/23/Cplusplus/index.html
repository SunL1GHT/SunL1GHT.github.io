<!DOCTYPE html><html lang="en"><head><!-- hexo injector head_begin start --><link href="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.1.1/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Gary Gu"><meta name="copyright" content="Gary Gu"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>C++实践记录 | 人生自留地</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.24/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/../images/favicon.ico"><link rel="mask-icon" href="/../images/favicon.ico" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"sunl1ght.github.io","root":"/","title":"海港浪声","version":"1.5.2","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"/data/sentences.json"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="人生自留地" type="application/atom+xml"><meta name="description" content="学习记录C语言和C++有什么区别和联系？&lt;&gt;引用系统头文件&quot;&quot;引用用户头文件多个程序包含同一个头文件，而不用注重引用顺序。 123456&#x2F;&#x2F;防卫式声明#ifdef __COMPLEX__#define __COMPLEX__# endif  基础入门循环语句for while&#x2F;do…while 基础进阶数组动态数组替代品——模板类vector定长数组替代品——模板类">
<meta property="og:type" content="article">
<meta property="og:title" content="C++实践记录">
<meta property="og:url" content="http://sunl1ght.github.io/2021/03/23/Cplusplus/index.html">
<meta property="og:site_name" content="人生自留地">
<meta property="og:description" content="学习记录C语言和C++有什么区别和联系？&lt;&gt;引用系统头文件&quot;&quot;引用用户头文件多个程序包含同一个头文件，而不用注重引用顺序。 123456&#x2F;&#x2F;防卫式声明#ifdef __COMPLEX__#define __COMPLEX__# endif  基础入门循环语句for while&#x2F;do…while 基础进阶数组动态数组替代品——模板类vector定长数组替代品——模板类">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20201206153943.png">
<meta property="article:published_time" content="2021-03-23T19:32:35.000Z">
<meta property="article:modified_time" content="2021-03-30T06:31:27.220Z">
<meta property="article:author" content="Gary Gu">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20201206153943.png"><script src="/js/ui/mode.js"></script></head><body><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Gary Gu"><img width="96" loading="lazy" src="/../images/penguin2-h.jpg" alt="Gary Gu"><span class="site-author-status" title="永远相信美好的事情即将发生">😊</span></a><div class="site-author-name"><a href="/about/">Gary Gu</a></div><a class="site-name" href="/about/site.html">人生自留地</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">6</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">3</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">7</span></a></div><a class="site-state-item hty-icon-button" href="/albums/" title="albums"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-gallery-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/SunL1GHT" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/3182176652" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/132851686/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/66248455" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">学习记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.</span> <span class="toc-text">基础入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">循环语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6"><span class="toc-number">1.2.</span> <span class="toc-text">基础进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E6%9B%BF%E4%BB%A3%E5%93%81%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E7%B1%BBvector"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">动态数组替代品——模板类vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84%E6%9B%BF%E4%BB%A3%E5%93%81%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E7%B1%BBarray"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">定长数组替代品——模板类array</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.2.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.2.4.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.5.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-number">1.2.6.</span> <span class="toc-text">共用体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.2.7.</span> <span class="toc-text">枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">核心编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">内存分区模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8F%90%E9%AB%98%EF%BC%88%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">函数提高（函数重载）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.4.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">多态</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.</span> <span class="toc-text">实践</span></a></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/C/" style="font-size: 30px; color: #0078e7">C++</a> <a href="/tags/Qt/" style="font-size: 12px; color: #999">Qt</a> <a href="/tags/%E4%B8%BB%E5%B9%B2%E7%BD%91%E7%BB%9C/" style="font-size: 12px; color: #999">主干网络</a> <a href="/tags/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/" style="font-size: 12px; color: #999">图像增强</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 12px; color: #999">数学</a> <a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 12px; color: #999">论文</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 12px; color: #999">随笔</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://sunl1ght.github.io/2021/03/23/Cplusplus/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Gary Gu"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="人生自留地"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++实践记录</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2021-03-23 19:32:35" itemprop="dateCreated datePublished" datetime="2021-03-23T19:32:35+00:00">2021-03-23</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2021-03-30 06:31:27" itemprop="dateModified" datetime="2021-03-30T06:31:27+00:00">2021-03-30</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="Word count in article"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="Word count in article">4k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Reading time"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="Reading time">14m</span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E5%B7%A5%E4%BD%9C%E5%AE%9E%E8%B7%B5/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">工作实践</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/C/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">C++</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><p>C语言和C++有什么区别和联系？<br><code>&lt;&gt;</code>引用系统头文件<br><code>&quot;&quot;</code>引用用户头文件<br>多个程序包含同一个头文件，而不用注重引用顺序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防卫式声明</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMPLEX__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h2><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p><strong>for</strong></p>
<p><strong>while/do…while</strong></p>
<h2 id="基础进阶"><a href="#基础进阶" class="headerlink" title="基础进阶"></a>基础进阶</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="动态数组替代品——模板类vector"><a href="#动态数组替代品——模板类vector" class="headerlink" title="动态数组替代品——模板类vector"></a>动态数组替代品——模板类vector</h4><h4 id="定长数组替代品——模板类array"><a href="#定长数组替代品——模板类array" class="headerlink" title="定长数组替代品——模板类array"></a>定长数组替代品——模板类array</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a1[<span class="number">4</span>]=&#123;<span class="number">1.2</span>, <span class="number">2.4</span>, <span class="number">3.6</span>, <span class="number">4.8</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">double</span>&gt; a2&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    a2[<span class="number">0</span>]=<span class="number">1.0</span>/<span class="number">3.0</span>;</span><br><span class="line">    a2[<span class="number">1</span>]=<span class="number">1.0</span>/<span class="number">5.0</span>;</span><br><span class="line">    a2[<span class="number">2</span>]=<span class="number">1.0</span>/<span class="number">7.0</span>;</span><br><span class="line">    a2[<span class="number">3</span>]=<span class="number">1.0</span>/<span class="number">9.0</span>;</span><br><span class="line"></span><br><span class="line">    array&lt;<span class="keyword">double</span>, 4&gt; a3 = &#123;<span class="number">3.14</span>, <span class="number">2.72</span>, <span class="number">1.62</span>, <span class="number">1.41</span>&#125;;</span><br><span class="line">    array&lt;<span class="keyword">double</span>, 4&gt; a4;</span><br><span class="line"></span><br><span class="line">    a4 = a3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>指针の作用</strong>：间接访问内存，可以通过指针来保存一个地址，指针就是地址。</p>
<p><strong>指针の声明</strong>：<code>数据类型 * 指针变量名;</code></p>
<p>指针前加 * 号，表示解引用，找到指针指向的内存中的数据。</p>
<p>指针所占的内存空间：<code>int *p; //在32位系统中，占用4个字节空间；在64位系统中，占用8个字节空间。</code></p>
<p>特别地，指针不论是什么类型，其所占内存空间都是4(或8)个字节。</p>
<p><em>一定要在指针应用解引用运算符</em>之前，将指针初始化为一个确定的的、适当的地址。*</p>
<p><strong>空指针</strong>：指针变量指向内存中编号为0（NULL）的空间，用于初始化指针变量。</p>
<p><em>注意：空指针所指向的内存地址是不可以访问的。</em></p>
<p><strong>野指针</strong>：指针指向非法的内存空间。</p>
<p>空指针和野指针都不是我们申请的空间，因此不要访问。</p>
<p><strong>const修饰指针</strong>：</p>
<ol>
<li><p>const修饰指针：常量指针，<code>const int * p=&amp;a;</code></p>
<p> 特点：指针的指向可以修改，但是指针指向的值不可以改</p>
<ul>
<li><p><code>*p=20;</code>（错，指针指向的值不可以改）</p>
</li>
<li><p><code>p=&amp;b;</code>（对，指针指向可以改）</p>
</li>
</ul>
</li>
<li><p>const修饰常量：指针常量，<code>int * const p=&amp;a;</code></p>
<p> 特点：指针的指向不可修改，但是指针指向的值可以改</p>
<ul>
<li><p><code>*p=20;</code>（对，指向的值可以改）</p>
</li>
<li><p><code>p=&amp;b;</code>（错，指针的指向不可修改）</p>
</li>
</ul>
</li>
<li><p><code>const int * const p=&amp;a;</code></p>
<p> 特点：指针指向和指针指向的值都不可修改</p>
<ul>
<li><p><code>*p=20;</code>（错，指向的值不可修改）</p>
</li>
<li><p><code>p=&amp;b;</code>（错，指针的指向不可修改）</p>
</li>
</ul>
</li>
</ol>
<p><strong>内存操作</strong></p>
<p>变量是在编译时分配的有名称的内存，指针在运行阶段分配未命名的内存以存储值。而在运行阶段需要为哪一种数据类型分类内存，我们会使用<code>new</code>关键字。</p>
<p><code>new</code>分配内存，<code>int *pn=new int;//new int 告诉程序，需要适合存储int的内存，pn指向的是内存而不是变量</code></p>
<p>new的动态联编的特性，使得它更适用于大型数据（数组、字符串、结构体等）。</p>
<ul>
<li>静态联编：在程序编译时分配内存空间。在创建数组时，不论程序是否使用都将占用一定内存。</li>
<li>动态联编：在程序运行时分配内存空间。在创建数组时，程序将在运行时确定数组的长度。</li>
</ul>
<p>变量的值和指针指向的值都存储在栈（stack）区，而<code>new</code>从堆（heap）区或者自由存储区（free store）开辟内存。</p>
<p><code>delete</code>释放内存，<code>delete pn;//释放pn指向的内存，但不会删除指针pn本身，因此可以将pn重新指向另一个新分配的内存块。</code></p>
<blockquote>
<p>一定要配对使用<code>new</code>和<code>delete</code>，否则会发生内存泄漏（memory leak），即被分配的内存再也无法使用，内存泄漏严重的，程序将由于不断寻找更多内存而终止。</p>
</blockquote>
<p>使用new和 delete时,应遵守以下规则：</p>
<ol>
<li><p>不要使用<code>delete</code>来释放不是<code>new</code>分配的内存。</p>
</li>
<li><p>不要使用<code>delete</code>释放同一个内存块两次（两个指针指向同一块内存空间）。</p>
</li>
<li><p>如果使用<code>new</code>日为数组分配内存,则应使用 <code>delete[]</code>来释放。</p>
</li>
<li><p>如果使用<code>new</code>为一个实体分配内存,则应使用 <code>delete(没有方括号)</code>来释放。</p>
</li>
<li><p>对空指针应用<code>delete</code>是安全的。</p>
</li>
</ol>
<p><strong>数组指针和指针数组</strong></p>
<ul>
<li>数组指针中<code>*pn</code>与<code>pn[0]</code>等价</li>
<li>C++允许指针和整数相加。加1的结果为原来的地址值加上指向的对象占用的总字节数。</li>
<li>亦可实现两指针的相减，获得两个指针的间隔。</li>
</ul>
<p><strong>结构体指针</strong><br>箭头运算符<code>-&gt;</code>，用来指向结构体中的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> volume;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line">…</span><br><span class="line">inflatable *ps = <span class="keyword">new</span> inflatable;</span><br><span class="line">ps-&gt;price;<span class="comment">//指向结构体中的price成员，等价于(*ps).price;</span></span><br></pre></td></tr></table></figure>

<p><em>区分何时使用<code>.</code>,<code>-&gt;</code>来访问结构体成员：如果结构标识符是结构名，则使用<code>.</code>；如果标识符是指向结构体的指针，则使用<code>-&gt;</code></em></p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>使用成员运算符<code>.</code>来访问各个成员。</p>
<h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>区别于结构体的可以同时存储int,long,double类型，共用体只能存储int,long,double一种<br>共用体常用于节省内存</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h2 id="核心编程"><a href="#核心编程" class="headerlink" title="核心编程"></a>核心编程</h2><h3 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h3><ul>
<li><p>代码区，存放二进制代码</p>
</li>
<li><p>全局区，存放全局变量、静态变量、常量</p>
</li>
<li><p>栈区，编译器自动释放，存放函数的参数值，局部变量值</p>
</li>
<li><p>堆区，由程序员分配和释放，若不释放，操作系统将会自动回收</p>
</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><strong>引用の作用</strong>：给变量起别名</p>
<p><strong>引用の声明</strong>：<code>数据类型 &amp;别名=原名;</code></p>
<blockquote>
<p><strong>注意事项</strong></p>
<ol>
<li><p>引用必须要初始化<br><code>int &amp;b;</code>   //不合法<code> </code>int &amp;b=a;` //合法</p>
</li>
<li><p>引用初始化后就不能更改了<br><code>int &amp;b=a;</code> //合法<br><code>int &amp;b=c;</code> //不合法，不能脚踏两只船</p>
</li>
</ol>
</blockquote>
<p><strong>引用作函数参数</strong><br>作用：使用引用来以形参更改实参<br>优点：简化指针，代替地址传递</p>
<p><strong>引用作函数的返回值</strong><br>如果函数的返回值是引用，这个函数就可以作为左值，相当于一个变量。</p>
<p><strong>引用的本质</strong><br>引用在C++中的内部实现是一个<strong>指针常量</strong>。<br>引用一旦初始化后就不能做改变。int * const b=&a;</p>
<p><strong>常量引用</strong><br>作用：修饰形参，防止误操作。</p>
<h3 id="函数提高（函数重载）"><a href="#函数提高（函数重载）" class="headerlink" title="函数提高（函数重载）"></a>函数提高（函数重载）</h3><p><strong>函数的默认值</strong><br><strong>语法</strong>：<code>返回值类型 函数名(参数=默认值)&#123;&#125;</code><br>如果我们自己传入数据，就用自己的数据，如果没有，那么就用默认值</p>
<p>注意事项：<br>1、如果某个位置已经有了默认参数，那么这个位置之后的，从左往右都必须要有默认值<br>2、如果函数的声明有了默认参数，那么这个函数的实现就不能有默认参数；声明和实现中的默认参数只能有一个。</p>
<p><strong>函数占位参数</strong><br>C++形参中可以有占位参数（只填数据类型），但是调用函数时必须填补位置值<br><strong>语法</strong>：<code>返回值类型 函数名(数据类型)&#123;&#125;</code></p>
<ul>
<li><p>目前阶段的占位参数还无法使用，之后会进行介绍。</p>
</li>
<li><p>占位参数还可以有默认参数</p>
</li>
</ul>
<p><strong>函数重载</strong></p>
<p><strong>作用</strong>：相同函数名，根据调用的参数选择合适的函数执行，提高复用性。</p>
<p>函数重载满足条件：</p>
<ol>
<li>同一作用域下（全局函数/成员函数……）</li>
<li>函数名相同</li>
<li>函数参数 <strong>类型不同/个数不同/顺序不同</strong></li>
</ol>
<p>注意事项：</p>
<ul>
<li>函数的返回值不可作为函数重载的条件</li>
<li>引用作为重载条件</li>
<li>函数重载和函数的默认参数</li>
</ul>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><blockquote>
<p>C++面向对象三大特性：<strong>封装、继承、多态</strong></p>
</blockquote>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul>
<li><p>将属性和行为作为一个整体，表现生活中的事物</p>
</li>
<li><p>将属性和行为加以权限控制，访问权限有三种：</p>
<ol>
<li>公共权限  public     成员在类内、外都可以访问</li>
<li>保护权限  protected  成员在类内可以访问，类外不可以访问 儿子可以访问父亲的保护内容</li>
<li>私有权限  private    成员在类内可以访问，类外不可以访问 儿子不可以访问父亲的隐私内容</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>成员属性私有化的优点</strong></p>
<ol>
<li>将所有成员属性设为私有，可以自己控制读写权限</li>
<li>对于写权限，我们可以检测数据的有效性</li>
</ol>
</blockquote>
<ul>
<li><p>struct 和 class的区别</p>
<ul>
<li><p>struct 默认权限为公有</p>
</li>
<li><p>class 默认权限为私有</p>
</li>
</ul>
</li>
</ul>
<p><strong>静态成员</strong><br>在成员变量和成员函数前加上关键字<code>static</code>，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li><p>静态static 成员变量</p>
<ul>
<li>所有对象共享同一份数据</li>
<li>在编译阶段分配内存（全局区）</li>
<li>类内声明，类外初始化</li>
</ul>
</li>
<li><p>静态static 成员函数</p>
<ul>
<li>所有对象共享一个函数</li>
<li>静态成员函数只能访问静态成员变量</li>
</ul>
</li>
</ul>
<p><strong>this指针</strong></p>
<p>非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>this指针指向别调用的成员函数所属的对象</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，可用this指针来区分</li>
<li>在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<p><strong>空指针访问成员函数</strong><br>C++中空指针调用成员函数的，但是也要注意有没有用到this指针<br>如果用到this指针，需要加以判断保证代码的健壮性</p>
<p><strong>const修饰成员函数</strong></p>
<p>常函数：</p>
<ul>
<li>成员函数后加const 就成为常函数</li>
<li>常函数内不可以修改成员属性</li>
<li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p>常对象：</p>
<ul>
<li>声明对象前加const 就成为常对象</li>
<li>常对象只能调用常函数</li>
</ul>
<details>
<summary>构造函数与析构函数</summary>

<p><strong>构造函数和析构函数</strong>：编译器自动调用（空实现），完成<strong>对象的初始化和清理</strong>工作。</p>
<p><strong>构造函数语法</strong>：<code>类名 ()&#123;&#125;</code></p>
<ol>
<li>构造函数，没有返回值，也没有void</li>
<li>函数名称与类名相同</li>
<li>构造函数可以有参数，因此可以发生重载</li>
<li>程序在调用对象是会自动调用构造，无需手动调用，而且只会调用一次。</li>
</ol>
<p><strong>析构函数语法</strong>：<code>~类名 ()&#123;&#125;</code></p>
<ol>
<li>析构函数，没有返回值，也没有void</li>
<li>函数名称与类名相同，在名称前面加上~号</li>
<li>析构函数没有参数，因此不能发生重载</li>
<li>程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次。</li>
</ol>
<p><strong>构造函数的分类以及调用</strong></p>
<p>两种分类方式：</p>
<ul>
<li>按参数分为：有参构造(<code>Person()</code>)和无参构造(<code>Person(int a)</code>)</li>
<li>按类型分为：普通构造和拷贝构造(<code>Person(const Person &amp;p)</code>)</li>
</ul>
<p>三种调用方式：</p>
<ul>
<li>括号法</li>
<li>显示法</li>
<li>隐式转换法</li>
</ul>
<blockquote>
<p>拷贝构造函数的调用时机</p>
<ol>
<li>使用一个已经创建完毕的对象来初始化一个新对象</li>
<li>值传递的方式给函数参数传值</li>
<li>以值的方式返回局部对象</li>
</ol>
</blockquote>
<p><strong>构造函数的调用规则</strong><br>C++默认提供：</p>
<ol>
<li>默认构造函数（无参，函数体为空，即空实现）</li>
<li>默认析构函数（无参，函数体为空）</li>
<li>默认拷贝构造函数（对属性进行值拷贝）</li>
</ol>
<p>调用规则是：</p>
<ul>
<li>如果写了一个有参构造函数，那C++就不会生成吗，默认构造函数，但仍会提供一个拷贝构造函数。</li>
<li>如果写了一个拷贝构造函数，那C++不会提供其他默认构造函数</li>
</ul>
<p><strong><center>深拷贝和浅拷贝</center></strong><br>浅拷贝：简单的赋值拷贝操作，编译器默认的m_Height=p.m_Height;<br>深拷贝：在堆区重新申请空间，进行拷贝操作，手动堆区开辟m_Height = new int(*p.m_Height);</p>
<blockquote>
<p>new开辟的空间在堆上，而一般声明的变量存放在栈上。</p>
<p>new出来的是一段空间的首地址。所以一般需要用指针来存放这段地址。</p>
</blockquote>
<p>编译器提供的<strong>拷贝构造函数</strong>是利用的<strong>浅拷贝操作</strong></p>
<p>浅拷贝会带来堆区的内存重复释放（必须要释放），所以需要深拷贝解决。</p>
<p>如果属性有在堆区开辟的，一定要提供构造函数，防止浅拷贝的问题</p>
</details>

<details>
<summary>友元</summary>

<p><strong>友元の作用</strong>：声明特殊函数访问私有属性<br>友元的关键字为<code>friend</code></p>
<ul>
<li><p>全局函数作友元，全局函数就有可以访问私有元素</p>
</li>
<li><p>类作友元，一个类可以访问另一个类中的私有属性。</p>
</li>
<li><p>成员函数作友元，成员函数就可以访问另一个类的私有属性</p>
</li>
</ul>
</details>

<details>
<summary>运算符重载</summary>

<blockquote>
<p>对已有的运算符重新进行定义，赋予另一种功能，以适应不同的数据类型。<br>总结:</p>
</blockquote>
<ol>
<li>对于内置的数据类型的表达式的运算符是不可以更改的</li>
<li>不要滥用运算符重载</li>
</ol>
<ul>
<li>加号运算符重载+，定义新的两个运算类型的加法</li>
<li>左移运算符重载&lt;&lt;，输出自定义的数据类型</li>
<li>递增运算符重载++，</li>
<li>赋值运算符重载</li>
<li>关系运算符重载</li>
<li>函数调用运算符重载</li>
</ul>
</details>

<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><strong>语法</strong>：<code>class 子类:继承方式 父类&#123;&#125;</code><br>子类 也称为 派生类<br>父类 也称为 基类</p>
<p>派生类中的成员，包含两大部分：<br>一类是从基类继承过来的，一类是自己增加的成员<br>从基类继承过来的表现其共性，而新增的成员体现了其个性。</p>
<p>继承的好处：减少重复代码</p>
<p>继承方式</p>
<ol>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20201206153943.png" alt="继承方式" loading="lazy"></p>
<p>对象模型<br>    父类中所有非静态成员属性都会被子类继承下去<br>    父类中私有成员属性是被编译器给隐藏了， 因此访问不到，但是也确实被继承下去了。</p>
<p>继承中的构造和析构顺序<br>    子类继承父类后，当创建子类对象，也会调用父类的构造函数。其顺序是<strong>父子子父</strong></p>
<p><strong>继承中同名成员的处理方式</strong></p>
<ul>
<li>访问子类中的同名成员，直接访问即可，<code>子.成员名</code></li>
<li>访问父类中的同名成员，需要<strong>加作用域</strong>，<code>子.父::成员名</code></li>
</ul>
<p><em>注意:如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有成员函数</em></p>
<p><strong>继承同名静态成员处理方式</strong><br>继承的静态变量在子类中如何访问呢？<br>实例化： 类名 对象名;<code>Son s;</code></p>
<ul>
<li>通过对象访问，<code>s.m_A 或 s.func()</code></li>
<li>通过类型进行访问，<code>Son::m_A 或 Son::func()</code><br>  如果重名，参考上面，只要<strong>加作用域</strong>即可</li>
</ul>
<p><strong>多继承</strong></p>
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分,<strong>C++实际开发中不建议使用多继承。</strong><br>语法:<code>class 子:继承方式 父1, 继承方式 父2</code></p>
<p><strong>菱形继承/钻石继承</strong><br>两个派生继承了同一个基类，又有一个类继承了上面的两个派生类</p>
<p>总结：</p>
<ul>
<li>菱形继承带的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li>
<li>利用虚继承可以解决菱形继承的问题</li>
</ul>
<p><strong>虚继承</strong></p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>socket通信，局域网聊天室，传输Mat图片</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Gary Gu</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://sunl1ght.github.io/2021/03/23/Cplusplus/" title="C++实践记录">http://sunl1ght.github.io/2021/03/23/Cplusplus/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2021/03/27/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/" rel="prev" title="矩阵求导"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">矩阵求导</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2021/03/23/%E4%B8%80%E6%AC%A1%E6%80%A7%E5%86%85%E7%AA%A5%E9%95%9C%E7%9A%84%E4%B8%BB%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" rel="next" title="一次性内窥镜的主机系统设计"><span class="post-nav-text">一次性内窥镜的主机系统设计</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Gary Gu</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.5.2</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script>const date = new Date();
const today = (date.getMonth() + 1) + "-" + date.getDate()
const mourn_days = ["5-12"]
if (mourn_days.includes(today)) {
  document.documentElement.style.filter = "grayscale(1)";
}</script></div><!-- hexo injector body_end start --><script src="https://cdn.jsdelivr.net/npm/hexo-widget-tree@0.1.1/js/index.js"></script><div id="widget-tree">
      <ul><li class="tree-list-item"><i class="toggle-post-icon gg-folder-add"></i><a class="tree-list-link" href="/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/">实验室</a><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/2021/03/28/Qt%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/" title="Qt学习实践"><i class="post-icon gg-file-document"></i>Qt学习实践</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/2021/03/23/%E4%B8%80%E6%AC%A1%E6%80%A7%E5%86%85%E7%AA%A5%E9%95%9C%E7%9A%84%E4%B8%BB%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="一次性内窥镜的主机系统设计"><i class="post-icon gg-file-document"></i>一次性内窥镜的主机系统设计</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/2021/03/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" title="深度学习"><i class="post-icon gg-file-document"></i>深度学习</a></li><li class="tree-list-item"><a class="tree-list-post-link" href="/2021/03/27/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/" title="矩阵求导"><i class="post-icon gg-file-document"></i>矩阵求导</a></li></ul></li><li class="tree-list-item"><i class="toggle-post-icon gg-folder-add"></i><a class="tree-list-link" href="/categories/%E5%B7%A5%E4%BD%9C%E5%AE%9E%E8%B7%B5/">工作实践</a><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/2021/03/23/Cplusplus/" title="C++实践记录"><i class="post-icon gg-file-document"></i>C++实践记录</a></li></ul></li><li class="tree-list-item"><i class="toggle-post-icon gg-folder-add"></i><a class="tree-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%93/">生活小结</a><ul class="tree-list-children"><li class="tree-list-item"><a class="tree-list-post-link" href="/2021/03/13/21march/" title="三月纪要"><i class="post-icon gg-file-document"></i>三月纪要</a></li></ul></li></ul>
        <div id="widget-tree-button">
          <i class="gg-chevron-right"></i>
        </div>
      </div><!-- hexo injector body_end end --></body></html>