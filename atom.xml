<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>人生自留地</title>
  
  
  <link href="http://sunl1ght.github.io/atom.xml" rel="self"/>
  
  <link href="http://sunl1ght.github.io/"/>
  <updated>2021-03-30T06:31:27.220Z</updated>
  <id>http://sunl1ght.github.io/</id>
  
  <author>
    <name>Gary Gu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Qt学习实践</title>
    <link href="http://sunl1ght.github.io/2021/03/28/Qt%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/"/>
    <id>http://sunl1ght.github.io/2021/03/28/Qt%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-03-28T19:33:00.000Z</published>
    <updated>2021-03-30T06:31:27.220Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前接触过了Pyqt(PySide2)，我觉得大概布局、控件都类似，具体地还得多做项目实践，比如局域网聊天室什么的。</p></blockquote><h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLabel&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="string">&quot;Hello Qt!&quot;</span>);</span><br><span class="line">    label -&gt; <span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>什么是Qt？</p><ul><li>Qt是1991年由奇趣科技开发的跨平台C++图形用户界面应用程序开发框架。</li></ul><p>QMainWindow、QWidget、QDialog三个基类：</p><ol><li><p><strong>QMainWindow</strong><br> QMainWindow 类提供一个有菜单条、锚接窗口（例如工具条）和一个状态条的主应用程序窗口。</p></li><li><p><strong>QWidget</strong><br> QWidgt 类是所有用户界面对象的基类。 窗口部件是用户界面的一个基本单元：它从窗 口系统接收鼠标、键盘和其它事件，并且在屏幕上绘制自己。</p></li><li><p><strong>QDialog</strong><br> QDialog 类是对话框窗口的基类。对话框窗口是主要用于短期任务以及和用户进行简要通讯的顶级窗口。</p></li></ol><p><strong><center>信号和槽</center></strong></p><p><strong><center>布局</center></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;之前接触过了Pyqt(PySide2)，我觉得大概布局、控件都类似，具体地还得多做项目实践，比如局域网聊天室什么的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;学习笔记&quot;&gt;&lt;a href=&quot;#学习笔记&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="实验室" scheme="http://sunl1ght.github.io/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
    <category term="C++" scheme="http://sunl1ght.github.io/tags/C/"/>
    
    <category term="Qt" scheme="http://sunl1ght.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>矩阵求导</title>
    <link href="http://sunl1ght.github.io/2021/03/27/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/"/>
    <id>http://sunl1ght.github.io/2021/03/27/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/</id>
    <published>2021-03-27T14:09:30.000Z</published>
    <updated>2021-03-30T06:31:27.220Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/24709748">矩阵求导术（上）</a><br><a href="https://zhuanlan.zhihu.com/p/24863977">矩阵求导术（下）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24709748&quot;&gt;矩阵求导术（上）&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24863977&quot;&gt;矩阵求导术（下）&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="实验室" scheme="http://sunl1ght.github.io/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
    <category term="数学" scheme="http://sunl1ght.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>C++实践记录</title>
    <link href="http://sunl1ght.github.io/2021/03/23/Cplusplus/"/>
    <id>http://sunl1ght.github.io/2021/03/23/Cplusplus/</id>
    <published>2021-03-23T19:32:35.000Z</published>
    <updated>2021-03-30T06:31:27.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><p>C语言和C++有什么区别和联系？<br><code>&lt;&gt;</code>引用系统头文件<br><code>&quot;&quot;</code>引用用户头文件<br>多个程序包含同一个头文件，而不用注重引用顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防卫式声明</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __COMPLEX__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h2><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p><strong>for</strong></p><p><strong>while/do…while</strong></p><h2 id="基础进阶"><a href="#基础进阶" class="headerlink" title="基础进阶"></a>基础进阶</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="动态数组替代品——模板类vector"><a href="#动态数组替代品——模板类vector" class="headerlink" title="动态数组替代品——模板类vector"></a>动态数组替代品——模板类vector</h4><h4 id="定长数组替代品——模板类array"><a href="#定长数组替代品——模板类array" class="headerlink" title="定长数组替代品——模板类array"></a>定长数组替代品——模板类array</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a1[<span class="number">4</span>]=&#123;<span class="number">1.2</span>, <span class="number">2.4</span>, <span class="number">3.6</span>, <span class="number">4.8</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">double</span>&gt; a2&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    a2[<span class="number">0</span>]=<span class="number">1.0</span>/<span class="number">3.0</span>;</span><br><span class="line">    a2[<span class="number">1</span>]=<span class="number">1.0</span>/<span class="number">5.0</span>;</span><br><span class="line">    a2[<span class="number">2</span>]=<span class="number">1.0</span>/<span class="number">7.0</span>;</span><br><span class="line">    a2[<span class="number">3</span>]=<span class="number">1.0</span>/<span class="number">9.0</span>;</span><br><span class="line"></span><br><span class="line">    array&lt;<span class="keyword">double</span>, 4&gt; a3 = &#123;<span class="number">3.14</span>, <span class="number">2.72</span>, <span class="number">1.62</span>, <span class="number">1.41</span>&#125;;</span><br><span class="line">    array&lt;<span class="keyword">double</span>, 4&gt; a4;</span><br><span class="line"></span><br><span class="line">    a4 = a3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>指针の作用</strong>：间接访问内存，可以通过指针来保存一个地址，指针就是地址。</p><p><strong>指针の声明</strong>：<code>数据类型 * 指针变量名;</code></p><p>指针前加 * 号，表示解引用，找到指针指向的内存中的数据。</p><p>指针所占的内存空间：<code>int *p; //在32位系统中，占用4个字节空间；在64位系统中，占用8个字节空间。</code></p><p>特别地，指针不论是什么类型，其所占内存空间都是4(或8)个字节。</p><p><em>一定要在指针应用解引用运算符</em>之前，将指针初始化为一个确定的的、适当的地址。*</p><p><strong>空指针</strong>：指针变量指向内存中编号为0（NULL）的空间，用于初始化指针变量。</p><p><em>注意：空指针所指向的内存地址是不可以访问的。</em></p><p><strong>野指针</strong>：指针指向非法的内存空间。</p><p>空指针和野指针都不是我们申请的空间，因此不要访问。</p><p><strong>const修饰指针</strong>：</p><ol><li><p>const修饰指针：常量指针，<code>const int * p=&amp;a;</code></p><p> 特点：指针的指向可以修改，但是指针指向的值不可以改</p><ul><li><p><code>*p=20;</code>（错，指针指向的值不可以改）</p></li><li><p><code>p=&amp;b;</code>（对，指针指向可以改）</p></li></ul></li><li><p>const修饰常量：指针常量，<code>int * const p=&amp;a;</code></p><p> 特点：指针的指向不可修改，但是指针指向的值可以改</p><ul><li><p><code>*p=20;</code>（对，指向的值可以改）</p></li><li><p><code>p=&amp;b;</code>（错，指针的指向不可修改）</p></li></ul></li><li><p><code>const int * const p=&amp;a;</code></p><p> 特点：指针指向和指针指向的值都不可修改</p><ul><li><p><code>*p=20;</code>（错，指向的值不可修改）</p></li><li><p><code>p=&amp;b;</code>（错，指针的指向不可修改）</p></li></ul></li></ol><p><strong>内存操作</strong></p><p>变量是在编译时分配的有名称的内存，指针在运行阶段分配未命名的内存以存储值。而在运行阶段需要为哪一种数据类型分类内存，我们会使用<code>new</code>关键字。</p><p><code>new</code>分配内存，<code>int *pn=new int;//new int 告诉程序，需要适合存储int的内存，pn指向的是内存而不是变量</code></p><p>new的动态联编的特性，使得它更适用于大型数据（数组、字符串、结构体等）。</p><ul><li>静态联编：在程序编译时分配内存空间。在创建数组时，不论程序是否使用都将占用一定内存。</li><li>动态联编：在程序运行时分配内存空间。在创建数组时，程序将在运行时确定数组的长度。</li></ul><p>变量的值和指针指向的值都存储在栈（stack）区，而<code>new</code>从堆（heap）区或者自由存储区（free store）开辟内存。</p><p><code>delete</code>释放内存，<code>delete pn;//释放pn指向的内存，但不会删除指针pn本身，因此可以将pn重新指向另一个新分配的内存块。</code></p><blockquote><p>一定要配对使用<code>new</code>和<code>delete</code>，否则会发生内存泄漏（memory leak），即被分配的内存再也无法使用，内存泄漏严重的，程序将由于不断寻找更多内存而终止。</p></blockquote><p>使用new和 delete时,应遵守以下规则：</p><ol><li><p>不要使用<code>delete</code>来释放不是<code>new</code>分配的内存。</p></li><li><p>不要使用<code>delete</code>释放同一个内存块两次（两个指针指向同一块内存空间）。</p></li><li><p>如果使用<code>new</code>日为数组分配内存,则应使用 <code>delete[]</code>来释放。</p></li><li><p>如果使用<code>new</code>为一个实体分配内存,则应使用 <code>delete(没有方括号)</code>来释放。</p></li><li><p>对空指针应用<code>delete</code>是安全的。</p></li></ol><p><strong>数组指针和指针数组</strong></p><ul><li>数组指针中<code>*pn</code>与<code>pn[0]</code>等价</li><li>C++允许指针和整数相加。加1的结果为原来的地址值加上指向的对象占用的总字节数。</li><li>亦可实现两指针的相减，获得两个指针的间隔。</li></ul><p><strong>结构体指针</strong><br>箭头运算符<code>-&gt;</code>，用来指向结构体中的成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inflatable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> volume;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;;</span><br><span class="line">…</span><br><span class="line">inflatable *ps = <span class="keyword">new</span> inflatable;</span><br><span class="line">ps-&gt;price;<span class="comment">//指向结构体中的price成员，等价于(*ps).price;</span></span><br></pre></td></tr></table></figure><p><em>区分何时使用<code>.</code>,<code>-&gt;</code>来访问结构体成员：如果结构标识符是结构名，则使用<code>.</code>；如果标识符是指向结构体的指针，则使用<code>-&gt;</code></em></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>使用成员运算符<code>.</code>来访问各个成员。</p><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>区别于结构体的可以同时存储int,long,double类型，共用体只能存储int,long,double一种<br>共用体常用于节省内存</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h2 id="核心编程"><a href="#核心编程" class="headerlink" title="核心编程"></a>核心编程</h2><h3 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h3><ul><li><p>代码区，存放二进制代码</p></li><li><p>全局区，存放全局变量、静态变量、常量</p></li><li><p>栈区，编译器自动释放，存放函数的参数值，局部变量值</p></li><li><p>堆区，由程序员分配和释放，若不释放，操作系统将会自动回收</p></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><strong>引用の作用</strong>：给变量起别名</p><p><strong>引用の声明</strong>：<code>数据类型 &amp;别名=原名;</code></p><blockquote><p><strong>注意事项</strong></p><ol><li><p>引用必须要初始化<br><code>int &amp;b;</code>   //不合法<code> </code>int &amp;b=a;` //合法</p></li><li><p>引用初始化后就不能更改了<br><code>int &amp;b=a;</code> //合法<br><code>int &amp;b=c;</code> //不合法，不能脚踏两只船</p></li></ol></blockquote><p><strong>引用作函数参数</strong><br>作用：使用引用来以形参更改实参<br>优点：简化指针，代替地址传递</p><p><strong>引用作函数的返回值</strong><br>如果函数的返回值是引用，这个函数就可以作为左值，相当于一个变量。</p><p><strong>引用的本质</strong><br>引用在C++中的内部实现是一个<strong>指针常量</strong>。<br>引用一旦初始化后就不能做改变。int * const b=&a;</p><p><strong>常量引用</strong><br>作用：修饰形参，防止误操作。</p><h3 id="函数提高（函数重载）"><a href="#函数提高（函数重载）" class="headerlink" title="函数提高（函数重载）"></a>函数提高（函数重载）</h3><p><strong>函数的默认值</strong><br><strong>语法</strong>：<code>返回值类型 函数名(参数=默认值)&#123;&#125;</code><br>如果我们自己传入数据，就用自己的数据，如果没有，那么就用默认值</p><p>注意事项：<br>1、如果某个位置已经有了默认参数，那么这个位置之后的，从左往右都必须要有默认值<br>2、如果函数的声明有了默认参数，那么这个函数的实现就不能有默认参数；声明和实现中的默认参数只能有一个。</p><p><strong>函数占位参数</strong><br>C++形参中可以有占位参数（只填数据类型），但是调用函数时必须填补位置值<br><strong>语法</strong>：<code>返回值类型 函数名(数据类型)&#123;&#125;</code></p><ul><li><p>目前阶段的占位参数还无法使用，之后会进行介绍。</p></li><li><p>占位参数还可以有默认参数</p></li></ul><p><strong>函数重载</strong></p><p><strong>作用</strong>：相同函数名，根据调用的参数选择合适的函数执行，提高复用性。</p><p>函数重载满足条件：</p><ol><li>同一作用域下（全局函数/成员函数……）</li><li>函数名相同</li><li>函数参数 <strong>类型不同/个数不同/顺序不同</strong></li></ol><p>注意事项：</p><ul><li>函数的返回值不可作为函数重载的条件</li><li>引用作为重载条件</li><li>函数重载和函数的默认参数</li></ul><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><blockquote><p>C++面向对象三大特性：<strong>封装、继承、多态</strong></p></blockquote><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li><p>将属性和行为作为一个整体，表现生活中的事物</p></li><li><p>将属性和行为加以权限控制，访问权限有三种：</p><ol><li>公共权限  public     成员在类内、外都可以访问</li><li>保护权限  protected  成员在类内可以访问，类外不可以访问 儿子可以访问父亲的保护内容</li><li>私有权限  private    成员在类内可以访问，类外不可以访问 儿子不可以访问父亲的隐私内容</li></ol></li></ul><blockquote><p><strong>成员属性私有化的优点</strong></p><ol><li>将所有成员属性设为私有，可以自己控制读写权限</li><li>对于写权限，我们可以检测数据的有效性</li></ol></blockquote><ul><li><p>struct 和 class的区别</p><ul><li><p>struct 默认权限为公有</p></li><li><p>class 默认权限为私有</p></li></ul></li></ul><p><strong>静态成员</strong><br>在成员变量和成员函数前加上关键字<code>static</code>，称为静态成员</p><p>静态成员分为：</p><ul><li><p>静态static 成员变量</p><ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存（全局区）</li><li>类内声明，类外初始化</li></ul></li><li><p>静态static 成员函数</p><ul><li>所有对象共享一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p><strong>this指针</strong></p><p>非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>this指针指向别调用的成员函数所属的对象</p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><p><strong>空指针访问成员函数</strong><br>C++中空指针调用成员函数的，但是也要注意有没有用到this指针<br>如果用到this指针，需要加以判断保证代码的健壮性</p><p><strong>const修饰成员函数</strong></p><p>常函数：</p><ul><li>成员函数后加const 就成为常函数</li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p>常对象：</p><ul><li>声明对象前加const 就成为常对象</li><li>常对象只能调用常函数</li></ul><details><summary>构造函数与析构函数</summary><p><strong>构造函数和析构函数</strong>：编译器自动调用（空实现），完成<strong>对象的初始化和清理</strong>工作。</p><p><strong>构造函数语法</strong>：<code>类名 ()&#123;&#125;</code></p><ol><li>构造函数，没有返回值，也没有void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象是会自动调用构造，无需手动调用，而且只会调用一次。</li></ol><p><strong>析构函数语法</strong>：<code>~类名 ()&#123;&#125;</code></p><ol><li>析构函数，没有返回值，也没有void</li><li>函数名称与类名相同，在名称前面加上~号</li><li>析构函数没有参数，因此不能发生重载</li><li>程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次。</li></ol><p><strong>构造函数的分类以及调用</strong></p><p>两种分类方式：</p><ul><li>按参数分为：有参构造(<code>Person()</code>)和无参构造(<code>Person(int a)</code>)</li><li>按类型分为：普通构造和拷贝构造(<code>Person(const Person &amp;p)</code>)</li></ul><p>三种调用方式：</p><ul><li>括号法</li><li>显示法</li><li>隐式转换法</li></ul><blockquote><p>拷贝构造函数的调用时机</p><ol><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值的方式返回局部对象</li></ol></blockquote><p><strong>构造函数的调用规则</strong><br>C++默认提供：</p><ol><li>默认构造函数（无参，函数体为空，即空实现）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝构造函数（对属性进行值拷贝）</li></ol><p>调用规则是：</p><ul><li>如果写了一个有参构造函数，那C++就不会生成吗，默认构造函数，但仍会提供一个拷贝构造函数。</li><li>如果写了一个拷贝构造函数，那C++不会提供其他默认构造函数</li></ul><p><strong><center>深拷贝和浅拷贝</center></strong><br>浅拷贝：简单的赋值拷贝操作，编译器默认的m_Height=p.m_Height;<br>深拷贝：在堆区重新申请空间，进行拷贝操作，手动堆区开辟m_Height = new int(*p.m_Height);</p><blockquote><p>new开辟的空间在堆上，而一般声明的变量存放在栈上。</p><p>new出来的是一段空间的首地址。所以一般需要用指针来存放这段地址。</p></blockquote><p>编译器提供的<strong>拷贝构造函数</strong>是利用的<strong>浅拷贝操作</strong></p><p>浅拷贝会带来堆区的内存重复释放（必须要释放），所以需要深拷贝解决。</p><p>如果属性有在堆区开辟的，一定要提供构造函数，防止浅拷贝的问题</p></details><details><summary>友元</summary><p><strong>友元の作用</strong>：声明特殊函数访问私有属性<br>友元的关键字为<code>friend</code></p><ul><li><p>全局函数作友元，全局函数就有可以访问私有元素</p></li><li><p>类作友元，一个类可以访问另一个类中的私有属性。</p></li><li><p>成员函数作友元，成员函数就可以访问另一个类的私有属性</p></li></ul></details><details><summary>运算符重载</summary><blockquote><p>对已有的运算符重新进行定义，赋予另一种功能，以适应不同的数据类型。<br>总结:</p></blockquote><ol><li>对于内置的数据类型的表达式的运算符是不可以更改的</li><li>不要滥用运算符重载</li></ol><ul><li>加号运算符重载+，定义新的两个运算类型的加法</li><li>左移运算符重载&lt;&lt;，输出自定义的数据类型</li><li>递增运算符重载++，</li><li>赋值运算符重载</li><li>关系运算符重载</li><li>函数调用运算符重载</li></ul></details><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><strong>语法</strong>：<code>class 子类:继承方式 父类&#123;&#125;</code><br>子类 也称为 派生类<br>父类 也称为 基类</p><p>派生类中的成员，包含两大部分：<br>一类是从基类继承过来的，一类是自己增加的成员<br>从基类继承过来的表现其共性，而新增的成员体现了其个性。</p><p>继承的好处：减少重复代码</p><p>继承方式</p><ol><li>公共继承</li><li>保护继承</li><li>私有继承</li></ol><p><img src="https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20201206153943.png" alt="继承方式" loading="lazy"></p><p>对象模型<br>    父类中所有非静态成员属性都会被子类继承下去<br>    父类中私有成员属性是被编译器给隐藏了， 因此访问不到，但是也确实被继承下去了。</p><p>继承中的构造和析构顺序<br>    子类继承父类后，当创建子类对象，也会调用父类的构造函数。其顺序是<strong>父子子父</strong></p><p><strong>继承中同名成员的处理方式</strong></p><ul><li>访问子类中的同名成员，直接访问即可，<code>子.成员名</code></li><li>访问父类中的同名成员，需要<strong>加作用域</strong>，<code>子.父::成员名</code></li></ul><p><em>注意:如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有成员函数</em></p><p><strong>继承同名静态成员处理方式</strong><br>继承的静态变量在子类中如何访问呢？<br>实例化： 类名 对象名;<code>Son s;</code></p><ul><li>通过对象访问，<code>s.m_A 或 s.func()</code></li><li>通过类型进行访问，<code>Son::m_A 或 Son::func()</code><br>  如果重名，参考上面，只要<strong>加作用域</strong>即可</li></ul><p><strong>多继承</strong></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分,<strong>C++实际开发中不建议使用多继承。</strong><br>语法:<code>class 子:继承方式 父1, 继承方式 父2</code></p><p><strong>菱形继承/钻石继承</strong><br>两个派生继承了同一个基类，又有一个类继承了上面的两个派生类</p><p>总结：</p><ul><li>菱形继承带的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承的问题</li></ul><p><strong>虚继承</strong></p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>socket通信，局域网聊天室，传输Mat图片</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习记录&quot;&gt;&lt;a href=&quot;#学习记录&quot; class=&quot;headerlink&quot; title=&quot;学习记录&quot;&gt;&lt;/a&gt;学习记录&lt;/h1&gt;&lt;p&gt;C语言和C++有什么区别和联系？&lt;br&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;引用系统头文件&lt;br&gt;&lt;code&gt;&amp;quo</summary>
      
    
    
    
    <category term="工作实践" scheme="http://sunl1ght.github.io/categories/%E5%B7%A5%E4%BD%9C%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="C++" scheme="http://sunl1ght.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>一次性内窥镜的主机系统设计</title>
    <link href="http://sunl1ght.github.io/2021/03/23/%E4%B8%80%E6%AC%A1%E6%80%A7%E5%86%85%E7%AA%A5%E9%95%9C%E7%9A%84%E4%B8%BB%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://sunl1ght.github.io/2021/03/23/%E4%B8%80%E6%AC%A1%E6%80%A7%E5%86%85%E7%AA%A5%E9%95%9C%E7%9A%84%E4%B8%BB%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-03-23T18:56:42.000Z</published>
    <updated>2021-03-30T06:31:27.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h2><ol><li>白平衡</li><li>色彩增强（红色血管、出血点颜色增强）</li><li>结构增强（显示细微轮廓）</li><li>录像/拍照</li><li>菜单：语言、存储格式、患者信息、增强功能设定、日期时间、视频输出格式、U盘格式化</li><li>照明亮度调节功能（控制镜头端LED亮度）</li><li>上下左右控制</li></ol><h2 id="内窥镜阶段计划书"><a href="#内窥镜阶段计划书" class="headerlink" title="内窥镜阶段计划书"></a>内窥镜阶段计划书</h2><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p><strong><center>图像处理</center></strong></p><ul><li>图像增强：<ul><li>白平衡，</li><li>颜色增强，</li><li>结构增强</li></ul></li></ul><p><strong><center>界面设计</center></strong></p><ul><li>显示日期时间</li><li>调用摄像头/读取视频</li><li>视频输出格式选择</li><li>图像显示</li><li>图像增强若干功能按键</li><li>U盘格式化按键</li><li>界面显示语言切换（中/英）</li></ul><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>软件</p><ul><li>引入神经网络中的超分辨率技术，完善结构增强功能</li></ul><p>硬件</p><ul><li>基于树莓派的软件控制，实现独立按钮控制</li><li>三档控制LED的亮度</li><li>多端通信及数据传输——显示器（HDMI）、PC端（TCP/IP）</li></ul><h2 id="实际实现——图像增强"><a href="#实际实现——图像增强" class="headerlink" title="实际实现——图像增强"></a>实际实现——图像增强</h2><details><summary>图像增强综述</summary><p>代码实现：<a href="https://www.cnblogs.com/fydeblog/p/10734733.html">https://www.cnblogs.com/fydeblog/p/10734733.html</a></p><ul><li>Point Operations<ul><li>Image Negative</li><li>Contrast Stretching</li><li>Compression of dynamic range</li><li>Grey level slicing</li><li>Image Subtraction</li><li>Image Averaging</li><li>Histogram<ul><li>Histogram Equalization</li><li>adaptive histogram equalization</li><li>Contrast Limited Adaptive Hitogram Equalization（CLAHE）</li></ul></li></ul></li><li>Mask Operations<ul><li>Smoothing operations</li><li>Median Filtering</li><li>sharpening operations</li><li>Derivative operations</li></ul></li><li>Transform operations<ul><li>Low pass filtering</li><li>High pass filtering</li><li>Band pass filtering</li><li>Homomorphic filtering</li></ul></li><li>Coloring Operations<ul><li>False coloring</li><li>Full color processing</li></ul></li><li>Retinex<ul><li>SSR</li><li>MSR</li><li>MSRCR</li><li>Experiment</li></ul></li><li>Dark Channel Prior</li></ul></details><h2 id="实际实现——超分辨率"><a href="#实际实现——超分辨率" class="headerlink" title="实际实现——超分辨率"></a>实际实现——超分辨率</h2><p>为什么要使用超分辨算法？<br>通常情况，图像传感器均能获得较好的质量，但在特殊场合，受到诸多因素影响，导致图像质量下降。如图像采集获取过程中：<strong>成像环境、成像距离、传感器形状和大小、光学系统的误差、空气扰动、物体运动、镜头散焦的影响。</strong></p><p>图像数字化处理过程中：成像、转换、编码、压缩、存储都会影响到图像的分辨率。另外<strong>，还有成像噪声、电气噪声、系统噪声的叠加</strong>。所以实际应用中，无法按照理想状况实现，存在的这些因素，必然影响图像的质量，获得较高质量的图像分辨率也是相当困难的。理论上，获得高分辨率只要增加成像系统的个数，最直接的方法是，通过传感器制造技术减小像素尺寸，增加单位面积的成像点阵就可以解决问题。</p><p>综上，由于技术水平和经济条件的限制，使得成像传感器和光学器件的性能指标可能无法满足应用的需要，因此，需要采用信号处理方法提高图像分辨率。</p><p><strong>经典的图像插值算法：</strong></p><ul><li>nearest（邻域像素重复技术）——放大像素大小但不增加细节，会简单地用与其最近邻相同的颜色填充空白像素。它虽然简单而有效，但结果是一个锯齿状、明显像素化的图像。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20210326185216.jpg" alt="nearest原理" loading="lazy"></p><ul><li>bilinear（双线性图像插值）——相似三角形原理，均值插值，以周围四个点来得到中间点的值，解决锯齿，但会产生模糊。基于最近的两个像素来分析空白像素，并在它们之间生成一个梯度，这会让图像变得更加清晰。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20210326185317.jpg" alt="bilinear原理" loading="lazy"></p><ul><li>bicubic（双三次图像插值），对其16个最近邻像素进行了采样，这样就会让着色变得精确，但仍然存在图像模糊的问题，R. G. Keys, “Cubic convolution interpolation for digital image processing,” IEEE Trans. On Acoustics, Speech, and Signal Processing, ASSP-29(6): 1153-1160, 1981.</li></ul><p>![插值算法对比](<a href="https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCfK7n1ltJhKRFKFcyL3syI8TmXdMJtATxKiarYmFLVcacDQhb9Aiapumj29TTPBg4W2sicSQDuUEwzg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1%5D">https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCfK7n1ltJhKRFKFcyL3syI8TmXdMJtATxKiarYmFLVcacDQhb9Aiapumj29TTPBg4W2sicSQDuUEwzg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1]</a></p><p>$$ g(x)=\sum\limits_k{c_k \cdot u(\frac {x-x_k}{h})} $$</p><p>$$ u(s)=\begin{cases} {A_1}{|s|^3}+{B_1}{|s|^2}+{C_1}{|s|}+{D_1} &amp; 0&lt;|s|&lt;1 \\ {A_2}{|s|^3}+{B_2}{|s|^2}+{C_2}{|s|}+{D_2} &amp; 1&lt;|s|&lt;2 \\ 0 &amp; 2&lt;{|s|} \end{cases} $$</p><p>将u(0)=1,u(1)=0,u(2)=0;s=0,1,2处u’连续A_2=0.5代入上式可得：</p><p>$$ u(s)=\begin{cases} \frac {3}{2}{|s|^3}-\frac {5}{2}{|s|^2}+1 &amp; 0&lt;|s|&lt;1 \\ -\frac {1}{2}{|s|^3}+\frac {5}{2}{|s|^2}-4{|s|}+2 &amp; 1&lt;|s|&lt;2 \\ 0 &amp; 2&lt;{|s|} \end{cases} $$</p><ul><li>边缘导向差值法——假设自然图像可以用局部的高斯随机过程来描述，基于几何对偶性算出协方差系数使得LR→HR。图片给更光滑，速度快。</li></ul><p>$$ \vec{\alpha}=(C^TC)^{-1}\cdot(C^{T}\vec{y}) $$</p><ul><li><p>in scale BP——单幅图的超分辨率：自相似性（图像内部自相似性以及不同尺寸的自相似性）</p><ul><li><p>in-scale：在图像内部搜索相似块，根据相似块计算平均值，放入放大的图像的对应位置</p></li><li><p>cross-scale：在不同尺寸（高斯金字塔）图像间搜索相似块，根据相似块计算平均值，放入放大的图像的对应位置</p></li></ul></li><li><p>Superresolution，【ICCV2009】D. Glasner, S. Bagon, and M. Irani, “Super-resolution from a single image,” In Proc. of ICCV, 2009.  </p><ul><li>back-Projection：缩小高分辨率图像与实际图像之间的误差</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/SunL1GHT/ImagePicGo@main/img/20210326184457.jpg" alt="处理流程" loading="lazy"></p><p>传统的基于插值的算法相比之下，神经网络的优势可以处理更多的信息，超分辨率算法可以分为以下两种：</p><ol><li><p>Single Image SR。只参考当前低分辨率图像，不依赖其他相关图像的超分辨率技术，称之为单幅图像的超分辨率（single image super resolution，SISR）。</p></li><li><p>Video SR。参考多幅图像或多个视频帧的超分辨率技术，称之为多帧视频/多图的超分辨率（multi-frame super resolution）。对于Video SR，其核心思想就是用时间带宽换取空间分辨率。简单来讲，就是在无法得到一张超高分辨率的图像时，可以多取相邻几帧，然后将这一系列低分辨率的图像组成一张高分辨的图像。</p></li></ol><p>一般来讲Video SR相比于Image SR具有更多的可参考信息，并具有更好的高分辨率视频图像的重建质量，但是其更高的计算复杂度也限制了其应用。</p><p>通常包括两个步骤：首先<strong>图像配准</strong>，即估计低分辨率图像之间亚像素级别的相对位移；其次<strong>图像融合</strong>，将多幅低分辨率图像融合成一幅高分辨率图像。</p><p><strong>分类</strong></p><p><strong><center>基于重建的方法</center></strong><br>通常都是基于多帧图像的，需要结合先验知识。有如下方法：</p><ul><li>凸集投影法（POCS)</li><li>贝叶斯分析方法</li><li>迭代反投影法（IBP）</li><li>最大后验概率方法</li><li>正规化法</li><li>混合方法</li></ul><p><strong><center>基于学习的图像超分辨率</center></strong><br>机器学习领域（非深度学习邻域）的图像超分方法如下：</p><ul><li>Example-based方法</li><li>邻域嵌入方法</li><li>支持向量回归方法</li><li>虚幻脸</li><li>稀疏表示法</li></ul><p><strong><center>基于深度学习的图像超分辨率重建技术</center></strong><br>基于深度学习的图像超分辨率重建的研究流程如下：<br>1，首先找到一组原始图像Image1；<br>2，然后将这组图片降低分辨率为一组图像Image2；<br>3，通过各种神经网络结构，将Image2超分辨率重建为Image3（Image3和Image1分辨率一样）<br>4，通过PSNR等方法比较Image1与Image3，验证超分辨率重建的效果，根据效果调节神经网络中的节点模型和参数<br>5，反复执行，直到第四步比较的结果满意</p><p><strong>简单试验几个超分辨率的<a href="https://bbs.cvmart.net/topics/949">神经网络模型</a>：</strong></p><p><img src="https://bbs.cvmart.net/uploads/images/201909/10/3/ExYpimih7z.png?imageView2/2/w/1240/h/0" alt="SRCNN" loading="lazy"></p><details><summary>SRCNN</summary><p><a href="https://www.bilibili.com/video/BV1pE411H7vd">SRCNN</a><br><a href="https://moyangsensei.github.io/2020/07/18/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%EF%BC%9ASRCNN/#%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84">论文研读：SRCNN</a></p></details><p><img src="https://bbs.cvmart.net/uploads/images/201909/10/3/TqII1h1Uyi.png?imageView2/2/w/1240/h/0" alt="DRCN" loading="lazy"></p><details><summary>DRCN</summary><p>提出使用更多的卷积层增加网络感受野（41x41），同时为了避免过多网络参数，该文章提出使用递归神经网络（RNN）。</p></details><p><img src="https://bbs.cvmart.net/uploads/images/201909/10/3/e7mc2ZJwJ7.png?imageView2/2/w/1240/h/0" alt="ESPCN" loading="lazy"></p><details><summary>ESPCN</summary><p>在SRCNN和DRCN中，低分辨率图像都是先通过上采样插值得到与高分辨率图像同样的大小，再作为网络输入，意味着卷积操作在较高的分辨率上进行，相比于在低分辨率的图像上计算卷积，会降低效率。</p></details><p><img src="https://bbs.cvmart.net/uploads/images/201909/10/3/lcTwlTetVQ.png?imageView2/2/w/1240/h/0" alt="VESPCN" loading="lazy"></p><details><summary>VESPCN</summary><p>在视频图像的SR问题中，相邻几帧具有很强的关联性，上述几种方法都只在单幅图像上进行处理，而VESPCN（ Real-Time Video Super-Resolution with Spatio-Temporal Networks and Motion Compensation, arxiv 2016）提出使用视频中的时间序列图像进行高分辨率重建，并且能达到实时处理的效率要求。</p></details><p><img src="https://bbs.cvmart.net/uploads/images/201909/10/3/L6AKms1aX0.png?imageView2/2/w/1240/h/0" alt="SRGAN" loading="lazy"></p><details><summary>SRGAN</summary><p>其出发点是传统的方法一般处理的是较小的放大倍数，当图像的放大倍数在4以上时，很容易使得到的结果显得过于平滑，而缺少一些细节上的真实感。因此SRGAN使用GAN来生成图像中的细节。</p><p>对抗学习的概念就是引入一个判别器来解决不同数据域之间分布不一致的问题，通过使判别器无法区分两个不同域的数据，间接使它们属于同一个分布，从而作为一个规则化的方法去指导深度学习模型更新参数，达到更好的效果。<a href="https://zhuanlan.zhihu.com/p/25201511">参考</a></p></details><p><img src="https://img2020.cnblogs.com/blog/2215171/202103/2215171-20210301091709616-1699615147.png" alt="Unfolding SuperResolution Network(USRNet) " loading="lazy"></p><details><summary>USRNet</summary><p><a href="https://www.cnblogs.com/froml77/p/14453391.html">Deep Unfolding Network for Image Super-Resolution (USRNet)论文解读</a></p><p>model-based：将问题公式化，然后通过不断迭代结果，最终得到一个令人较为满意的解</p><p>learning-based：深度学习的方法</p><p>「单图像超分」《Deep Unfolding Network for Image Super-Resolution》</p><p>no-blind已知LR图像，下采样方法，模糊核，噪声的情况下，求对应的HR图像。</p></details><h2 id="实际实现——Qt界面"><a href="#实际实现——Qt界面" class="headerlink" title="实际实现——Qt界面"></a>实际实现——Qt界面</h2><p><strong>调用摄像头</strong></p><p><a href="https://github.com/hjrf/fruit-recognition/blob/master/fruit-identification/%E8%B0%83%E7%94%A8%E7%94%B5%E8%84%91%E6%91%84%E5%83%8F%E5%A4%B4.cpp">https://github.com/hjrf/fruit-recognition/blob/master/fruit-identification/%E8%B0%83%E7%94%A8%E7%94%B5%E8%84%91%E6%91%84%E5%83%8F%E5%A4%B4.cpp</a></p><p><strong>功能按键</strong></p><h2 id="实际实现——云服务器进行训练部署"><a href="#实际实现——云服务器进行训练部署" class="headerlink" title="实际实现——云服务器进行训练部署"></a>实际实现——云服务器进行训练部署</h2><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>Docker 是一个开放源代码软件，是一个开放平台，用于开发应用、交付（shipping）应用、运行应用。 Docker允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。</p><p>Docker容器与虚拟机类似，但二者在原理上不同。容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。 容器更多的用于表示 软件的一个标准化单元。由于容器的标准化，因此它可以无视基础设施（Infrastructure）的差异，部署到任何一个地方。另外，Docker也为容器提供更强的业界的隔离兼容。</p><p>参考<br>[1]: <a href="https://blog.csdn.net/weixin_42535423/article/details/114303505">超分辨率重建基础知识总结</a><br>[2]: <a href="https://moyangsensei.github.io/2020/07/18/%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/">基础：图像超分辨率</a><br>[3]: <a href="https://blog.csdn.net/liangchunjiang/article/details/79030681">CNN详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;功能需求&quot;&gt;&lt;a href=&quot;#功能需求&quot; class=&quot;headerlink&quot; title=&quot;功能需求&quot;&gt;&lt;/a&gt;功能需求&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;白平衡&lt;/li&gt;
&lt;li&gt;色彩增强（红色血管、出血点颜色增强）&lt;/li&gt;
&lt;li&gt;结构增强（显示细微轮廓）&lt;/l</summary>
      
    
    
    
    <category term="实验室" scheme="http://sunl1ght.github.io/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
    <category term="图像增强" scheme="http://sunl1ght.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA/"/>
    
  </entry>
  
  <entry>
    <title>深度学习</title>
    <link href="http://sunl1ght.github.io/2021/03/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://sunl1ght.github.io/2021/03/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-03-22T14:34:00.000Z</published>
    <updated>2021-03-30T06:31:27.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主干网络对比"><a href="#主干网络对比" class="headerlink" title="主干网络对比"></a>主干网络对比</h2><p>评估数据</p><p>1、<strong>top-1错误</strong>：如果模型预测的置信度最高的类与真正的类不相同，则会发生top-1错误。</p><p>2、<strong>top-5错误</strong>：当真正的类不在模型预测置信度最高的前5个类中时，会发生前top-5错误（按置信度排序）。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGVhcm5vcGVuY3YuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE5LzA2L0FjY3VyYWN5LUNvbXBhcmlzb24tb2YtTW9kZWxzLnBuZw?x-oss-process=image/format,png" alt="Accuracy Comparison of Models" loading="lazy"></p><p>3、<strong>CPU的推断时间</strong>：推断时间是模型推理过程所花费的时间。</p><p>4、<strong>GPU的推断时间</strong> : 当推理运行于gpu时，所花费的推理时间。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGVhcm5vcGVuY3YuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE5LzA2L01vZGVsLUluZmVyZW5jZS1UaW1lLUNvbXBhcmlzb24tb24tQ1BVLW1zLUxvd2VyLWlzLWJldHRlci0ucG5n?x-oss-process=image/format,png" alt="Inference time on CPU comparison" loading="lazy"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGVhcm5vcGVuY3YuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE5LzA2L01vZGVsLUluZmVyZW5jZS1UaW1lLUNvbXBhcmlzb24tb24tR1BVLW1zLUxvd2VyLWlzLWJldHRlci0ucG5n?x-oss-process=image/format,png" alt="Inference time on GPU comparison" loading="lazy"></p><p>5、<strong>模型大小</strong>：这里的大小代表由PyTorch提供的预训练模型的.pth（或.pt) 文件所占用的物理空间。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGVhcm5vcGVuY3YuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE5LzA2L01vZGVsLVNpemUtQ29tcGFyaXNvbi5wbmc?x-oss-process=image/format,png" alt="Model size comparison" loading="lazy">一个好的模型将具有低的TOP-1错误，低的TOP-5错误，低的CPU和GPU上的推理时间和低的模型大小。 所有的实验都是在同一个输入图像上进行的，并且多次进行，这样就可以将特定模型的所有结果的平均值进行分析。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cubGVhcm5vcGVuY3YuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE5LzA2L1ByZS1UcmFpbmVkLU1vZGVsLUNvbXBhcmlzb24ucG5n?x-oss-process=image/format,png" alt="img" loading="lazy"></p><p>CIFAR-10上Resnet18对比，超参数设置如下</p><table><thead><tr><th>EPOCH</th><th>BATCH_SIZE</th><th>LEARNING_RATE</th></tr></thead><tbody><tr><td>135</td><td>128</td><td>0.01</td></tr></tbody></table><p>EPOCH=103，best_acc= 92.190%</p><p>EPOCH=102，best_acc= 91.950%</p><p>EPOCH=132,best_acc= 92.430%（改进算法分类）</p><p>基于机器视觉的模块化输电网的异物检测300~500</p><p><strong>Datasets</strong>:[Oxford Flowers-102][1],102类，Size (train/test)：Size (train/test)</p><table><thead><tr><th>Network</th><th>TOP-1 acc%</th><th>TOP-5 acc%</th><th>[FLOPs][2]</th><th>Params.</th></tr></thead><tbody><tr><td>Resnet-50</td><td></td><td></td><td></td><td>23,705,252</td></tr><tr><td>Efficientnet-b0</td><td></td><td></td><td></td><td>5,288,548</td></tr><tr><td>Rexnet-1.0x</td><td></td><td></td><td></td><td>4,796,873</td></tr></tbody></table><blockquote><p><a href="CNN%E6%A8%A1%E5%9E%8B%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88FLOPs%E3%80%81MAC%EF%BC%89%E3%80%81%E5%8F%82%E6%95%B0%E9%87%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6_%E5%BC%A0%E9%B9%8F%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2(https://blog.csdn.net/weixin_39833897/article/details/105807172)"><strong>模型复杂度</strong></a></p><p>描述一个具体的深度学习模型，除了性能指标（分类任务的准确度、检测任务的mAP等），还需要考虑该模型的复杂度，即参数(Parameters，使用Mb作为单位)的个数和（前向推理的）计算量（使用FLOPs（FLoating point OPerations）或MAC(Memory Access Cost)衡量）。</p><p>前者描述了这个复杂的网络到底需要多少参数才能定义它，即存储该模型所需的存储空间。后者描述了数据过一遍这么复杂的网络需要多大的计算量呢，即使用该模型时所需的计算力。</p></blockquote><p>对于一个卷积层，假设其大小为$h×w×c×n$（其中c为#input channel, n为#output channel），输出的feature map尺寸为$H’×W’$，则该卷积层的</p><p>$#paras = n×（h×w×c+1）$</p><p>$ #FLOPs = H’×W’×N(H×W×C+1)，即FLOPs=H’×W’×#paras $</p><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><h4 id="torchvision"><a href="#torchvision" class="headerlink" title="torchvision"></a><a href="https://pytorch.org/docs/1.0.0/torchvision/models.html">torchvision</a></h4><table><thead><tr><th>Model</th><th>Input Resolution</th><th>Params(M)</th><th>MACs(G)</th><th>Top-1 error</th><th>Top-5 error</th></tr></thead><tbody><tr><td>alexnet</td><td>224x224</td><td>61.1</td><td>0.72</td><td>43.45</td><td>20.91</td></tr><tr><td>vgg11</td><td>224x224</td><td>132.86</td><td>7.63</td><td>30.98</td><td>11.37</td></tr><tr><td>vgg13</td><td>224x224</td><td>133.05</td><td>11.34</td><td>30.07</td><td>10.75</td></tr><tr><td>vgg16</td><td>224x224</td><td>138.36</td><td>15.5</td><td>28.41</td><td>9.62</td></tr><tr><td>vgg19</td><td>224x224</td><td>143.67</td><td>19.67</td><td>27.62</td><td>9.12</td></tr><tr><td>vgg11_bn</td><td>224x224</td><td>132.87</td><td>7.64</td><td>29.62</td><td>10.19</td></tr><tr><td>vgg13_bn</td><td>224x224</td><td>133.05</td><td>11.36</td><td>28.45</td><td>9.63</td></tr><tr><td>vgg16_bn</td><td>224x224</td><td>138.37</td><td>15.53</td><td>26.63</td><td>8.50</td></tr><tr><td>vgg19_bn</td><td>224x224</td><td>143.68</td><td>19.7</td><td>25.76</td><td>8.15</td></tr><tr><td>resnet18</td><td>224x224</td><td>11.69</td><td>1.82</td><td>30.24</td><td>10.92</td></tr><tr><td>resnet34</td><td>224x224</td><td>21.8</td><td>3.68</td><td>26.70</td><td>8.58</td></tr><tr><td>resnet50</td><td>224x224</td><td>25.56</td><td>4.12</td><td>23.85</td><td>7.13</td></tr><tr><td>resnet101</td><td>224x224</td><td>44.55</td><td>7.85</td><td>22.63</td><td>6.44</td></tr><tr><td>resnet152</td><td>224x224</td><td>60.19</td><td>11.58</td><td>21.69</td><td>5.94</td></tr><tr><td>squeezenet1_0</td><td>224x224</td><td>1.25</td><td>0.83</td><td>41.90</td><td>19.58</td></tr><tr><td>squeezenet1_1</td><td>224x224</td><td>1.24</td><td>0.36</td><td>41.81</td><td>19.38</td></tr><tr><td>densenet121</td><td>224x224</td><td>7.98</td><td>2.88</td><td>25.35</td><td>7.83</td></tr><tr><td>densenet169</td><td>224x224</td><td>14.15</td><td>3.42</td><td>24.00</td><td>7.00</td></tr><tr><td>densenet201</td><td>224x224</td><td>20.01</td><td>4.37</td><td>22.80</td><td>6.43</td></tr><tr><td>densenet161</td><td>224x224</td><td>28.68</td><td>7.82</td><td>22.35</td><td>6.20</td></tr><tr><td>inception_v3</td><td>224x224</td><td>27.16</td><td>2.85</td><td>22.55</td><td>6.44</td></tr></tbody></table><ul><li>Top-1 error - ImageNet single-crop top-1 error (224x224)</li><li>Top-5 error - ImageNet single-crop top-5 error (224x224)</li></ul><h4 id="Cadene-pretrained-models-pytorch"><a href="#Cadene-pretrained-models-pytorch" class="headerlink" title="Cadene/pretrained-models.pytorch"></a><a href="https://github.com/Cadene/pretrained-models.pytorch">Cadene/pretrained-models.pytorch</a></h4><table><thead><tr><th>Model</th><th>Input Resolution</th><th>Params(M)</th><th>MACs(G)</th><th>Acc@1</th><th>Acc@5</th></tr></thead><tbody><tr><td>alexnet</td><td>224x224</td><td>61.1</td><td>0.72</td><td>56.432</td><td>79.194</td></tr><tr><td>bninception</td><td>224x224</td><td>11.3</td><td>2.05</td><td>73.524</td><td>91.562</td></tr><tr><td>cafferesnet101</td><td>224x224</td><td>44.55</td><td>7.62</td><td>76.2</td><td>92.766</td></tr><tr><td>densenet121</td><td>224x224</td><td>7.98</td><td>2.88</td><td>74.646</td><td>92.136</td></tr><tr><td>densenet161</td><td>224x224</td><td>28.68</td><td>7.82</td><td>77.56</td><td>93.798</td></tr><tr><td>densenet169</td><td>224x224</td><td>14.15</td><td>3.42</td><td>76.026</td><td>92.992</td></tr><tr><td>densenet201</td><td>224x224</td><td>20.01</td><td>4.37</td><td>77.152</td><td>93.548</td></tr><tr><td>dpn107</td><td>224x224</td><td>86.92</td><td>18.42</td><td>79.746</td><td>94.684</td></tr><tr><td>dpn131</td><td>224x224</td><td>79.25</td><td>16.13</td><td>79.432</td><td>94.574</td></tr><tr><td>dpn68</td><td>224x224</td><td>12.61</td><td>2.36</td><td>75.868</td><td>92.774</td></tr><tr><td>dpn68b</td><td>224x224</td><td>12.61</td><td>2.36</td><td>77.034</td><td>93.59</td></tr><tr><td>dpn92</td><td>224x224</td><td>37.67</td><td>6.56</td><td>79.4</td><td>94.62</td></tr><tr><td>dpn98</td><td>224x224</td><td>61.57</td><td>11.76</td><td>79.224</td><td>94.488</td></tr><tr><td>fbresnet152</td><td>224x224</td><td>60.27</td><td>11.6</td><td>77.386</td><td>93.594</td></tr><tr><td>inceptionresnetv2</td><td>299x299</td><td>55.84</td><td>13.22</td><td>80.17</td><td>95.234</td></tr><tr><td>inceptionv3</td><td>299x299</td><td>27.16</td><td>5.73</td><td>77.294</td><td>93.454</td></tr><tr><td>inceptionv4</td><td>299x299</td><td>42.68</td><td>12.31</td><td>80.062</td><td>94.926</td></tr><tr><td>nasnetalarge</td><td>331x331</td><td>88.75</td><td>24.04</td><td>82.566</td><td>96.086</td></tr><tr><td>nasnetamobile</td><td>224x224</td><td>5.29</td><td>0.59</td><td>74.08</td><td>91.74</td></tr><tr><td>pnasnet5large</td><td>331x331</td><td>86.06</td><td>25.21</td><td>82.736</td><td>95.992</td></tr><tr><td>polynet</td><td>331x331</td><td>95.37</td><td>34.9</td><td>81.002</td><td>95.624</td></tr><tr><td>resnet101</td><td>224x224</td><td>44.55</td><td>7.85</td><td>77.438</td><td>93.672</td></tr><tr><td>resnet152</td><td>224x224</td><td>60.19</td><td>11.58</td><td>78.428</td><td>94.11</td></tr><tr><td>resnet18</td><td>224x224</td><td>11.69</td><td>1.82</td><td>70.142</td><td>89.274</td></tr><tr><td>resnet34</td><td>224x224</td><td>21.8</td><td>3.68</td><td>73.554</td><td>91.456</td></tr><tr><td>resnet50</td><td>224x224</td><td>25.56</td><td>4.12</td><td>76.002</td><td>92.98</td></tr><tr><td>resnext101_32x4d</td><td>224x224</td><td>44.18</td><td>8.03</td><td>78.188</td><td>93.886</td></tr><tr><td>resnext101_64x4d</td><td>224x224</td><td>83.46</td><td>15.55</td><td>78.956</td><td>94.252</td></tr><tr><td>se_resnet101</td><td>224x224</td><td>49.33</td><td>7.63</td><td>78.396</td><td>94.258</td></tr><tr><td>se_resnet152</td><td>224x224</td><td>66.82</td><td>11.37</td><td>78.658</td><td>94.374</td></tr><tr><td>se_resnet50</td><td>224x224</td><td>28.09</td><td>3.9</td><td>77.636</td><td>93.752</td></tr><tr><td>se_resnext101_32x4d</td><td>224x224</td><td>48.96</td><td>8.05</td><td>80.236</td><td>95.028</td></tr><tr><td>se_resnext50_32x4d</td><td>224x224</td><td>27.56</td><td>4.28</td><td>79.076</td><td>94.434</td></tr><tr><td>senet154</td><td>224x224</td><td>115.09</td><td>20.82</td><td>81.304</td><td>95.498</td></tr><tr><td>squeezenet1_0</td><td>224x224</td><td>1.25</td><td>0.83</td><td>58.108</td><td>80.428</td></tr><tr><td>squeezenet1_1</td><td>224x224</td><td>1.24</td><td>0.36</td><td>58.25</td><td>80.8</td></tr><tr><td>vgg11</td><td>224x224</td><td>132.86</td><td>7.63</td><td>68.97</td><td>88.746</td></tr><tr><td>vgg11_bn</td><td>224x224</td><td>132.87</td><td>7.64</td><td>70.452</td><td>89.818</td></tr><tr><td>vgg13</td><td>224x224</td><td>133.05</td><td>11.34</td><td>69.662</td><td>89.264</td></tr><tr><td>vgg13_bn</td><td>224x224</td><td>133.05</td><td>11.36</td><td>71.508</td><td>90.494</td></tr><tr><td>vgg16</td><td>224x224</td><td>138.36</td><td>15.5</td><td>71.636</td><td>90.354</td></tr><tr><td>vgg16_bn</td><td>224x224</td><td>138.37</td><td>15.53</td><td>73.518</td><td>91.608</td></tr><tr><td>vgg19</td><td>224x224</td><td>143.67</td><td>19.67</td><td>72.08</td><td>90.822</td></tr><tr><td>vgg19_bn</td><td>224x224</td><td>143.68</td><td>19.7</td><td>74.266</td><td>92.066</td></tr><tr><td>xception</td><td>299x299</td><td>22.86</td><td>8.42</td><td>78.888</td><td>94.292</td></tr></tbody></table><ul><li>Acc@1 - ImageNet single-crop top-1 accuracy on validation images of the same size used during the training process.</li><li>Acc@5 - ImageNet single-crop top-5 accuracy on validation images of the same size used during the training process.</li></ul><h3 id="消融实验"><a href="#消融实验" class="headerlink" title="消融实验"></a>消融实验</h3><h2 id="胶囊学习"><a href="#胶囊学习" class="headerlink" title="胶囊学习"></a>胶囊学习</h2><p><a href="https://easyai.tech/ai-definition/capsule/">https://easyai.tech/ai-definition/capsule/</a></p><h2 id="图像超分辨"><a href="#图像超分辨" class="headerlink" title="图像超分辨"></a>图像超分辨</h2><blockquote><p>应用：模糊视频的实时处理</p></blockquote><p><a href="https://github.com/subeeshvasu/Awesome-Deblurring">https://github.com/subeeshvasu/Awesome-Deblurring</a></p><h3 id="图像质量评估"><a href="#图像质量评估" class="headerlink" title="图像质量评估"></a>图像质量评估</h3><p><a href="https://www.cnblogs.com/vincent2012/archive/2012/10/13/2723152.html">https://www.cnblogs.com/vincent2012/archive/2012/10/13/2723152.html</a></p><ul><li>PSNR，即峰值信噪比</li></ul><p>$$ PSNR=10\times\log{\frac {255^2}{MSE}} $$</p><p>$$ MSE=\frac {\sum\limits_{n=1}^{\text{Framesize}}[(I^n-P^n)^2]} {\text{Framesize}} $$</p><ul><li>MSE：均方误差</li><li>$I^n$：原始图像的第n个像素值</li><li>$P^n$：处理后图像的第n个像素值</li><li>Framesize：像素长*像素宽</li></ul><h3 id="端到端学习"><a href="#端到端学习" class="headerlink" title="端到端学习"></a>端到端学习</h3><p><a href="https://cloud.tencent.com/developer/article/1647850">https://cloud.tencent.com/developer/article/1647850</a></p><h4 id="USRNet"><a href="#USRNet" class="headerlink" title="USRNet"></a><a href="https://github.com/cszn/USRNet">USRNet</a></h4><p><a href="https://blog.csdn.net/qq_37614597/article/details/114786923">https://blog.csdn.net/qq_37614597/article/details/114786923</a></p><p><a href="https://inf.news/zh-hans/technique/556625fbf1051cb48fbb97013b66ae9b.html">https://inf.news/zh-hans/technique/556625fbf1051cb48fbb97013b66ae9b.html</a></p><p><a href="https://github.com/geopi1/Improved_USRNet">https://github.com/geopi1/Improved_USRNet</a></p><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><h3 id="模型结构可视化"><a href="#模型结构可视化" class="headerlink" title="模型结构可视化"></a>模型结构可视化</h3><p>Tensorboard</p><h3 id="Pytorch训练过程可视化"><a href="#Pytorch训练过程可视化" class="headerlink" title="Pytorch训练过程可视化"></a>Pytorch训练过程可视化</h3><p> Visdom可视化</p><h3 id="CNN训练图片可视化"><a href="#CNN训练图片可视化" class="headerlink" title="CNN训练图片可视化"></a>CNN训练图片可视化</h3><p>【教学使用——了解卷积内部操作过程】<a href="https://poloclub.github.io/cnn-explainer/">https://poloclub.github.io/cnn-explainer/</a></p><p><a href="https://github.com/taishan1994/pytorch-cnn-visualizations">taishan1994/pytorch-cnn-visualizations: Pytorch implementation of convolutional neural network visualization techniques (github.com)</a></p><p>[1]:M.-E. Nilsback and A. Zisserman. Automated flower classification over a large number of classes. In 2008 Sixth Indian Conference on Computer Vision, Graphics &amp; Image Processing, pages 722–729. IEEE, 2008, <a href="https://www.robots.ox.ac.uk/~vgg/data/flowers/102/">Visual Geometry Group - University of Oxford</a><br>[2]:FLOPS：floating point operations per second的缩写，意指每秒浮点运算次数，理解为计算速度。是一个衡量硬件性能的指标。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主干网络对比&quot;&gt;&lt;a href=&quot;#主干网络对比&quot; class=&quot;headerlink&quot; title=&quot;主干网络对比&quot;&gt;&lt;/a&gt;主干网络对比&lt;/h2&gt;&lt;p&gt;评估数据&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;top-1错误&lt;/strong&gt;：如果模型预测的置信度最高的类与</summary>
      
    
    
    
    <category term="实验室" scheme="http://sunl1ght.github.io/categories/%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
    <category term="主干网络" scheme="http://sunl1ght.github.io/tags/%E4%B8%BB%E5%B9%B2%E7%BD%91%E7%BB%9C/"/>
    
    <category term="论文" scheme="http://sunl1ght.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>三月纪要</title>
    <link href="http://sunl1ght.github.io/2021/03/13/21march/"/>
    <id>http://sunl1ght.github.io/2021/03/13/21march/</id>
    <published>2021-03-13T14:25:00.000Z</published>
    <updated>2021-03-30T06:31:27.220Z</updated>
    
    <content type="html"><![CDATA[<p>二零二一年的三月，相比于去年也热闹不少，此时的武汉已是樱花遍地，好不热闹的景象吧。</p><p>借此献给研一最后的疯狂。</p><h2 id="三月十四，周日"><a href="#三月十四，周日" class="headerlink" title="三月十四，周日"></a>三月十四，周日</h2><h3 id="顾村公园游记"><a href="#顾村公园游记" class="headerlink" title="顾村公园游记"></a>顾村公园游记</h3><p><a href="https://sunl1ght.github.io/albums/gucun.html">https://sunl1ght.github.io/albums/gucun.html</a></p><h2 id="宁波好春光"><a href="#宁波好春光" class="headerlink" title="宁波好春光"></a>宁波好春光</h2><p><a href="https://sunl1ght.github.io/albums/ningbo.html">https://sunl1ght.github.io/albums/ningbo.html</a><br>宁波有的是满眼浮华，贫富差距，富人想要更富，穷人只能更穷。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二零二一年的三月，相比于去年也热闹不少，此时的武汉已是樱花遍地，好不热闹的景象吧。&lt;/p&gt;
&lt;p&gt;借此献给研一最后的疯狂。&lt;/p&gt;
&lt;h2 id=&quot;三月十四，周日&quot;&gt;&lt;a href=&quot;#三月十四，周日&quot; class=&quot;headerlink&quot; title=&quot;三月十四，周日&quot;&gt;</summary>
      
    
    
    
    <category term="生活小结" scheme="http://sunl1ght.github.io/categories/%E7%94%9F%E6%B4%BB%E5%B0%8F%E7%BB%93/"/>
    
    
    <category term="随笔" scheme="http://sunl1ght.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
